<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【翻译】Rust笔记：Type Layouts和ABIs</title>
      <link href="/2019/03/10/rust-abi/"/>
      <url>/2019/03/10/rust-abi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文阐述了Rust中类型在内存中的布局及ABI相关的知识，对于学习rust ffi很有帮助。</p><p>原文地址：<a href="https://gankro.github.io/blah/rust-layouts-and-abis/" target="_blank" rel="noopener">https://gankro.github.io/blah/rust-layouts-and-abis/</a></p></blockquote><a id="more"></a><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><table><thead><tr><th style="text-align:left">英文</th><th>中文</th></tr></thead><tbody><tr><td style="text-align:left">Platform</td><td>平台</td></tr><tr><td style="text-align:left">Two’s complement</td><td>补码</td></tr><tr><td style="text-align:left">Alignment</td><td>字节对齐</td></tr><tr><td style="text-align:left">padding</td><td>填充</td></tr><tr><td style="text-align:left">layout</td><td>(类型在内存里的）布局</td></tr><tr><td style="text-align:left">SIMD</td><td>single instruction multiple data，单指令多数据</td></tr><tr><td style="text-align:left">Endianness/byte-order</td><td>端序、字节序</td></tr><tr><td style="text-align:left">big-endian/little-endian</td><td>大端序、小端序</td></tr><tr><td style="text-align:left">calling convention</td><td>调用约定</td></tr><tr><td style="text-align:left">vtable</td><td>虚函数表</td></tr><tr><td style="text-align:left">stack frame</td><td>栈帧</td></tr></tbody></table><h1 id="解剖平台"><a href="#解剖平台" class="headerlink" title="解剖平台"></a>解剖平台</h1><p>市面上有很多独树一帜的平台，C语言就像被绑架了一样要支持所有的这些平台。有些平台的变种非常的令人讨厌但是在技术上又是合理的，因为这些都是当时平台间确实是存在的差异所造成的。比如说不用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%A3%9C%E6%95%B8" target="_blank" rel="noopener">补码</a>来表示整数，又比如说不用8位来表示一个字节（char）。其他的则是C语言中人为的错误，例如：整型大小的模糊定义以及类型<a href="http://www.cnblogs.com/bbsno1/p/3279709.html" target="_blank" rel="noopener">提升规则</a>。</p><p>曾经C语言想要解决的很多问题，很大程度上已经不存在或者被放到更底层的平台了。因此，Rust在兼具C的跨平台兼容性的情况下，得以定义它所支持的平台的更多特性。</p><p>像Rust一样完全支持一个平台，标准C语言必须满足以下约束：</p><ul><li><p>具备 8位不对齐的字节（字符）</p></li><li><p>布尔值为1个字节，其中<code>true=1</code>，<code>false=0</code></p></li><li><p>整数用补码表示</p></li><li><p>如果二进制浮点数存在的话（我们可以禁用），需要支持<a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754(-2008?)</a>定义的二进制浮点数</p></li><li><p>至少需要16位（就指针大小而言？）</p></li><li><p>支持将NULL转为0</p></li></ul><p>（在运行标准库的时候还会有其他约束，如支持原子操作）</p><p>对现代的程序员来说，这些都是非常合理的约束。实际上，如果上述约束中的任意一条不成立都会让大部分的程序员感到惊讶！据我所知，只有一些DSP(数字信号处理器)是不遵守上述约束的最后堡垒，因为它们真的不喜欢8位的字节。为了让99.9999%的Rust用户拥有更干净的语言，Rust不支持这些DSP。</p><p>Rust 明确支持下列平台特性，尽管它们马上就要消逝了：</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F" target="_blank" rel="noopener">大端序 整数/浮点数</a></p></li><li><p>16位指针（由社区志愿者维护，最低支持MSP430微处理器）</p></li></ul><p>Rust可能会支持下列特性，但是还没有真正考虑过，可能我会做出了一个会让事情变得更糟糕的决定：</p><ul><li><p><a href="https://gankro.github.io/blah/rust-layouts-and-abis/#segmented-architectures" target="_blank" rel="noopener">细分架构</a></p></li><li><p><code>ptrdiffi_t = intptr_t = ssize_t</code>不成立的平台</p></li></ul><h1 id="剖析类型"><a href="#剖析类型" class="headerlink" title="剖析类型"></a>剖析类型</h1><p>类型定义了几个用于操作和读取类型值的属性。如果仅仅知道这些属性中的某一些，那么只有执行某些特定的操作才是安全的。</p><p>如果对某个类型一无所知，那么你唯一能做的就是以类型安全的方式向它传递指针。例如，你使用的库定义了一个类型，它需要你保留某些指向它的指针，但是有不希望你通过这些指针访问数据。这种情况下就可以通过向回调函数状态。Rust中把这种类型叫做<a href="https://github.com/rust-lang/rfcs/blob/master/text/1861-extern-types.md">外部类型</a>。</p><p>截止撰写本文时，外部类型还是实验性的。<code>struct MyType { }</code>语法也可以实现类似的目的，但是如果对这个类型存取值，编译器不会报错，而是默默地忽略这些操作。</p><h2 id="大小（size）"><a href="#大小（size）" class="headerlink" title="大小（size）"></a>大小（size）</h2><p>类型最基本的属性是大小：表示在内存中占用多少字节。在仅知道一个类型的大小的情况下，可以操作元素为该类型的数组的指针偏移量，也可以在该类型的指针之间复制值。数组中各元素的地址之间的步长总是等于元素的大小。尽管寄存器不是Rust中的语义模型，但是类型的值也可以通过寄存器来存取。</p><p>与C/C++不同的是，Rust中，类型的大小可以是0（zero-sized type, ZST，零大小类型）。通常这种类型仅用来表示它在内存中不存在，因此对它进行读/写实际上不会做任何事情。</p><p>类型的大小也可能根据它的值来确定，例如<code>[t]</code>和<code>Trait</code>类型。这种类型没有实现本应该被实现的Sizedtrait。一些通用的函数如果也要适用于这种类型，则必须传入<code>&lt;T: ?Sized&gt;</code>。</p><h2 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h2><p>类型第二个最基本的属性是字节对齐：它在内存中的存储位置必须是多少字节的倍数（当存储在内存中时）。例如，一个按4字节对齐的类型只可以被存储在0、4、8等位置。有了大小和字节对齐，就可以分配内存来存储类型的值。</p><p>字节对齐的值最小为1，且必须等于2的n次幂。大小则是字节对齐的倍数。类型的字段通常按其最大对齐字节来对齐。为了满足字节对齐的要求，类型中需要引入填充字节，而填充字节在逻辑上是不会被初始化的，这是因为类型的大小或相对位置需要取整才能满足字节对齐的要求。不管对填充部分读还是写，都不能保证得到期望的结果。</p><p>字节对齐对硬件来说更是必不可少，因为硬件对操作有一定的一致性要求。在很多情况下，非对齐访问“只会”导致严重的性能下降，但是某些情况下，硬件会因为不对齐而抛出异常。在某种意义上，硬件怎么运行其实并不是很重要，因为编译器会假设指针是对齐的，如果不对齐会导致编译错误！</p><p>零大小类型的字节对齐可能会大于1（如，<code>[u32; 0</code>]的字节对齐是<code>u32</code>，也就是4）。尽管ZST并不在内存中，该类型的字段和指针仍然需要对齐，因此ZST类型也会影响包含该类型的组合类型的布局、大小和字节对齐。</p><p>值得一提的是，像i386系统 V ABI（x86 linux C ABI）等较老的ABI对齐的方式稍微有点奇怪。当一个<code>double</code>类型放在结构体中的时候，它按4字节对齐，但是在堆上则永远按8字节对齐。Rust通过永远按4字节对齐来兼容这种情况，而不像C一样不能区别一个<code>double</code>类型的指针是结构体的一部分还是指针自身的一部分。</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>类型的偏移量指的是它每个字段的相对位置。偏移量在Rust中存在以下三种可能性：</p><ul><li><p>偏移量是不确定的</p></li><li><p>偏移量的排列顺序是确定的，但是偏移量的精确值不确定</p></li><li><p>偏移量的精确值是确定的</p></li></ul><p>这里对确定性的定义比较微妙。这里的确定性指的是：根据结构体的定义及其目标平台就能确定结构体内字段的偏移量。默认情况下，用户自定义的Rust类型的偏移量是不确定的，这是因为不同版本的编译器会选择不同的偏移量，或者后续的构建会导致产生不同的偏移量（尽管如此，我们永远不会将两个具有不同类型偏移量的rust代码链接在一起）。</p><p>看两个典型的例子：</p><pre><code class="rust">// 虽然这两个结构体相同，但是并没有要求Rust编译器对它们的字段应用相同的偏移量struct A(u32, u64);struct B(u32, u64);// 下面的结构体并不要求Rust编译器按照定义的顺序来构造字段。// 例如：在内存中，y可能被放在x前面struct Rect {    x: f32,    y: f32,    w: f32,    h: f32,}</code></pre><p>这么设计是出于两个目的：优化和模糊。</p><p>在优化方面，通常不依赖精确的结构体布局，因此上述的偏移设计十分有利于优化。尤其是对泛型结构，可能不存在一个适用于所有类型替换的最佳布局。例如，下面的结构体的所有字段就不能有一个单一的最佳顺序：</p><pre><code class="rust">struct Impossible&lt;T, U, V&gt; {    t: T,    u: U,    v: V,}</code></pre><p>例如，用<code>u16</code>，<code>u16</code>和<code>u32</code>分别替换T,U和V。只要<code>u32</code>不是第二个元素，这个结构体就会紧密地排列。然而，不论我们选择怎样的顺序，都必须要在中间位置放一个元素，而且我们可能将中间元素的类型改为<code>u32</code>，这就会使得这个顺序不是最佳的。因此，泛型结构中的字段没有一个单一的最佳排列顺序。</p><p>模糊（目前为止还没有被用到）的作用是允许字段的排列顺序随机化，以便更容易暴露隐藏的bug。</p><p>后面的章节中将会讨论到，某些注释会使人误以为字段是按顺序排列的。但是如果一个类型的字段没有确定的排列顺序，那么它的大小也可能是不确定的，这也会导致外层的类型也没有确定的偏移量。</p><p>例如，下面的结构的字段具有确定的排列顺序，但是各字段的偏移量是不确定的：</p><pre><code class="rust">#[repr(C)]struct MyStruct {    x: u32,    y: Vec&lt;u8&gt;,    z: u32,}</code></pre><p><code>Vec</code>没有确定的排序，因此尽管我们明确知道<code>x</code>和<code>y</code>存储位置的偏移值，我们也不能确定<code>z</code>的偏移值或者<code>MyStruct</code>的大小，因为它们依赖于y的大小，而它是不能确切知道的。因此，这个类型不适用于C的FFI。</p><p>实际上，也有可能是默认情况下对齐也是不确定的导致的？这样的话，y的偏移量也就未知了。这一点有待确认，<a href="https://github.com/rust-rfcs/unsafe-code-guidelines/issues/11">Rust 开发者正在积极讨论中</a>。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>类型的布局是指它的大小、字节对齐、偏移量在内存里的分布，并递归它的字段的布局。</p><p>如果知道一个类型的完整布局，就可以访问这个类型的所有字段。这也使得在具有兼容布局的类型间相互转换成为可能。我实在想不到一个严格的定义来描述兼容布局。通常来说，如果某块内存在两种类型中的位置相同，那么就可以把这两种类型中的一个类型看成是另一个，并知道这块内存反生了什么。这在Rust中是完全合法的，因为Rust没有基于类型的别名分析（TBAA,也叫做”严格别名”）。</p><p>例如，可以这样来实现继承：</p><pre><code class="rust">#[repr(C)]struct Base {    x: u32,    y: u64,    is_derived: bool,}#[repr(C)]struct Derived {    base: Base,    z: f32,}fn process&lt;&#39;a&gt;(data: &amp;&#39;a Base) {    print!(&quot;x: {}, y: {}&quot;, base.x, base.y);    if data.is_derived {        // upcast from Base to Derived        let derived = unsafe { mem::transmute::&lt;&amp;&#39;a Base, &amp;&#39;a Derived&gt;(data) };        print!(&quot;, z: {}&quot;, derived.z);    }    println!(&quot;&quot;);}</code></pre><p>如果能在C/C++中用兼容布局实现一个类型声明，就可以用引用的方式将这个类型的值通过FFI传递，在FFI的两边都可以读/写所有的字段。</p><h2 id="ABI"><a href="#ABI" class="headerlink" title="ABI"></a>ABI</h2><p>如果只是在Rust中，知道一个类型的布局就足以做任何事情了，但是不足以支持与C语言无障碍通信。实际上，仅知道类型布局不足以支持按值传递的方式将数据传给C语言函数。只是因为在类型的ABI(Application Binary Interface)有其他的属性。一个类型的ABI决定了它的值是如何传递给C语言函数的。</p><p>据我所知，ABI唯一特有的属性是type-kind。虽然<code>#[repr(C)] struct MyType(u32)</code>，<code>u32</code>和<code>f32</code>在给定的目标平台上的布局是兼容的，但是它们的ABI仍然不兼容，因为它们具有不同的type-kind。</p><p>截止本文，Rust需要考虑以下4种type-kind：</p><ul><li><p>整数 integer（指针被当作整数，但是以后可能会有变动）</p></li><li><p>浮点数 float</p></li><li><p>集合 aggregate</p></li><li><p>Vector</p></li></ul><blockquote><p>注意：type-kind不是官方的概念，用在这里只是便于描述ABI。所有的规范性性文件中都找不到这个概念，但是它与<a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf#section.3.2" target="_blank" rel="noopener">sysv x64 ABI 3.2.3节</a>中提到的类型的“class”概念类似。</p></blockquote><p>整数和浮点type-kind代表了一个基本类型可能具有的两种类别。如果两个类型具有相同的大小、字节对齐以及基本type-kind，那么它们的ABI就完全兼容（例如，x64 linux平台上的u64和usize具有一致的ABI）。</p><p>结构体、枚举和组合类型默认具有集合type-kind。但是集合type-kind可以在一定的条件和注解下转换为另外三种type-kind。详见后文。</p><p>所有C的结构体和组合类型都具有集合type-kind，C的SIMD类型具有Vector type-kind，而C的枚举类型具有整数type-kind。</p><p>集合和vector type-kind的准确ABI取决于它们各字段值的准确ABI是什么。例如，下面两个类型在x64 linux平台上具有不同的ABI，虽然它们有相同的大小、字节对齐和type-kind：</p><pre><code class="rust">#[repr(C)]struct Homo(u64, u64);#[repr(C)]struct Hetero(u64, f64);</code></pre><h2 id="Rust内置类型的布局-ABI"><a href="#Rust内置类型的布局-ABI" class="headerlink" title="Rust内置类型的布局/ABI"></a>Rust内置类型的布局/ABI</h2><p>下表列出了Rust中内置的核心基本类型的ABI、与他们ABI兼容的C/C++类型，以及给这些基本类型的取值范围（对一个类型存储其他值会被当作undefined）：</p><table><thead><tr><th></th><th>大小</th><th>字节对齐</th><th>type-kind</th><th>C/C++类型</th><th>取值范围</th></tr></thead><tbody><tr><td>u8</td><td>1</td><td>1</td><td>integer</td><td>uint8_t</td><td>all</td></tr><tr><td>u16</td><td>2</td><td>≤2</td><td>integer</td><td>uint16_t</td><td>all</td></tr><tr><td>u32</td><td>4</td><td>≤4</td><td>integer</td><td>uint32_t</td><td>all</td></tr><tr><td>u64</td><td>8</td><td>≤8</td><td>integer</td><td>uint64_t</td><td>all</td></tr><tr><td>u128</td><td>16</td><td>≤16</td><td>N/A</td><td>N/A</td><td>all</td></tr><tr><td>usize</td><td>ptr</td><td>ptr</td><td>integer</td><td>uintptr_t</td><td>all</td></tr><tr><td>i8</td><td>1</td><td>1</td><td>integer</td><td>int8_t</td><td>all</td></tr><tr><td>i16</td><td>2</td><td>≤2</td><td>integer</td><td>int16_t</td><td>all</td></tr><tr><td>i32</td><td>4</td><td>≤4</td><td>integer</td><td>int32_t</td><td>all</td></tr><tr><td>i64</td><td>8</td><td>≤8</td><td>integer</td><td>int64_t</td><td>all</td></tr><tr><td>i128</td><td>16</td><td>≤16</td><td>N/A</td><td>N/A</td><td>all</td></tr><tr><td>isize</td><td>ptr</td><td>ptr</td><td>integer</td><td>intptr_t</td><td>all</td></tr><tr><td>*const T</td><td>ptr</td><td>ptr</td><td>integer</td><td>T*</td><td>all</td></tr><tr><td>*mut T</td><td>ptr</td><td>ptr</td><td>integer</td><td>T*</td><td>all</td></tr><tr><td>&amp;T</td><td>ptr</td><td>ptr</td><td>integer</td><td>T*</td><td>not null</td></tr><tr><td>&amp;mut T</td><td>ptr</td><td>ptr</td><td>integer</td><td>T*</td><td>not null</td></tr><tr><td>Option&lt;&amp;T&gt;</td><td>ptr</td><td>ptr</td><td>integer</td><td>T*</td><td>all</td></tr><tr><td>Option&lt;&amp;mut T&gt;</td><td>ptr</td><td>ptr</td><td>integer</td><td>T*</td><td>all</td></tr><tr><td>bool</td><td>1</td><td>1</td><td>integer</td><td>bool(_Bool)</td><td>0=false, 1=true</td></tr><tr><td>char</td><td>4</td><td>≤4</td><td>N/A</td><td>N/A</td><td>0x0-0xD7FF, 0xE000-0x10FFFF</td></tr><tr><td>f32</td><td>4</td><td>≤4</td><td>float</td><td>float</td><td>all</td></tr><tr><td>f64</td><td>8</td><td>≤8</td><td>float</td><td>double</td><td>all</td></tr></tbody></table><p>理论上，<code>u128</code>和<code>i128</code>应该会兼容<code>__int128</code>的ABI，但是<a href="https://github.com/rust-lang/rust/issues/54341">由于llvm中的一个bug</a>，目前还不兼容。同样的，我们可能也可以定义Rust的<code>char</code>类型来兼容C++的<code>char32_t</code>，但是目前为止还没有人太关心并尝试解决这个问题。</p><p>需要注意的是，实际上基本类型通常会对齐它们的大小。字节对齐比大小更小往往意味着这个类型是在当前平台通过软件仿真出来的（如，<code>u64</code>在x86 linux平台的对齐值为4）。当然，类型的大小和字节对齐是编译目标的标准C实现所要关心的，这里我们主要关心的是兼容性。</p><p>Rust的数组（<code>[T; n]</code>）与C数组具有相同的布局：与<code>T</code>对齐，大小为<code>n * size_of::&lt;T&gt;()</code>，元素<code>i</code>的字节偏移是<code>i * size_of::&lt;T&gt;()</code>。但是数据目前没有特定的type-kind，因此数组不能在C中不能按值传递（<code>void func(int x[5]</code>的语法与<code>void func(int* x)</code>是相等的）。</p><p>除了<code>()</code>外，元组没有特定的布局。<code>()</code>的大小是0，对齐值是1。</p><h2 id="特殊的布局和ABI"><a href="#特殊的布局和ABI" class="headerlink" title="特殊的布局和ABI"></a>特殊的布局和ABI</h2><p>下面这些特殊的注释会影响布局和ABI：</p><ul><li><p><code>#[repr(c)]</code>：作用于结构体时，会根据C的规则，强制将结构体的各字段按照声明的顺序排列，填充采用贪婪的方式。如果所有的字段都具有完整定义的布局，则这个类型具有完整定义的布局。注意，这个注释有纯rust的应用，如类型双关或者继承，而且<code>#[repr(c)</code>实际上不保证被作用的类型是FFI安全的。</p></li><li><p><code>#[repr(simd)]</code>：作用于结构体时，与<code>#[repr(c)]</code>作用一样，只不过这个注释会给类型添加vctor type-kind。这个特性目前还不稳定，稳定之路也不可欺。从长远来看，稳定的vector type-kind会在标准库中提供使用。短期内，可以通过<code>simd</code>crate来使用它的不稳定版本。</p></li><li><p><code>#[repr(transparent)]</code>：作用于只有一个字段的结构体时，使得这个结构体具有它的字段的ABI。所以，如果结构体包含一个<code>i32</code>类型的字段，那么它就有了<code>i32</code>的ABI。通常情况下，只有需要获得匹配的type-kind时才会这么做，因为大小和字节对齐会自动匹配字段类型。这个特性在构造FFI安全的新整数类型时尤其有用。</p></li><li><p><code>#[repr(packed(N))]</code>：作用于结构体，移除所有的尾部填充并设置类型的字节对齐为N，使得它与C中包装好的结构体兼容。注意，这会使得结构体中的字段布局时产生错位。直接访问这些字段会生成代码去管理这种不对齐，但是通过指针访问却是危险的，因为编译器会“忘记”这些字段是不对齐的，从而按对齐的方式访问，以致发生 undefined行为。</p></li><li><p><code>#[repr(align=x)]</code>：作用于结构体，强制结构体至少向<code>x</code>对齐。这个特性可能会影响大小。</p></li><li><p><code>#[repr(c)]</code>：作用于没有字段的枚举，使得该枚举变量的ABI与声明相同的C枚举的ABI相同。所以，该枚举会具有目标C枚举的任意整数类型（通常是<code>int</code>?）的整数type-kind，大小和对齐。注意，不像C一样，Rust中不能不赋值。</p></li><li><p><code>#[repr(int)]</code>（其中<code>int</code>是任意的基础类型，如<code>u8</code>）：作用于没有字段的枚举，使得该枚举具有与给定整数类型相同的ABI。这一点对于匹配C++中的<code>enum MyEnum: some-int-type</code>非常有用。注意，不像C一样，Rust中不能不赋值。</p></li><li><p><code>#[repr(int)]</code>或者<code>#[repr(C)]</code>：作用于有字段的枚举，使得该枚举有<a href="https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md">兼容C的标记化组合表示特性</a></p></li></ul><p>上述是我知道的Rust中所有用来定义内存布局和ABI的内容！</p><h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><h2 id="C语言整数层级结构"><a href="#C语言整数层级结构" class="headerlink" title="C语言整数层级结构"></a>C语言整数层级结构</h2><p>C语言需要解决两个问题：不同平台的字节（可寻址内存的最小单位）大小是不同的；不同的平台具有不同的“原生”（效率最高/最重要）整数大小。</p><p>C语言从两个方面来解决这个问题：给目标平台的内存单位定义一个类型(<code>char</code>)，然后定义一套整数的层级结构，不同层级间具有不同的大小约束。理论上，这样C代码就是可移植的，可以在10位、16位、32位等所有的平台运行良好。</p><p>对主要的整数类型的约束如下：</p><ul><li><p><code>char</code>至少有8位，所有其他类型整数必须是这个大小(<code>CHAR_BIT</code>)的整数倍</p></li><li><p><code>short</code>至少有16位，同时至少要有一个<code>char</code>的位数</p></li><li><p><code>int</code>至少有<code>short</code>的位数（目的是要作为“原生”整数大小）</p></li><li><p><code>long</code>至少有32位，同时至少要有一个<code>int</code>的位数</p></li><li><p><code>long long</code>至少有64位，同时至少有一个<code>long</code>的位数</p></li></ul><p>表面上看，这套整数层级结构十分合理：如果想存一个16位的值，那就用<code>short</code>类型；如果想存一个32位的值，就用<code>long</code>类型。存多大的位数都可以，但是这可能吗？</p><p>答案是否，因为事实证明了解类型准确的大小是很重要的！如果想要从某些二进制格式中精确地读/写32位，应该怎么做呢？如果用<code>long</code>，可能会访问到64位！另外，哪种类型适合用于存储指针呢？(<code>intptr_t</code>只在C99中加入了）</p><p>这不仅仅是理论上的顾虑。在32位机时代，把<code>int</code>准确地设定为32位是约定俗成的，以至于64位硬件刚开始出现的时候，编译器开发者被迫将<code>int</code>类型仍定义成32位，因为将<code>int</code>定义为其它位数会使得大部分软件彻底无法运行。</p><p>当然，关于<code>int</code>的点都是基于它是“原生”的整数大小的假设，这反过来让编译器开发者相信，在位数真的有影响的情况下，如果允许<code>int</code>隐式提升到64位，会导致未定义的有符号整数溢出。</p><p>曾经又一封很好的编译器开发（gcc？）邮件讲述了这段历史，但是我找不到了。所以暂且用<a href="https://gist.github.com/rygorous/e0f055bfb74e3d5f0af20690759de5a7" target="_blank" rel="noopener">这篇文章</a>的讨论来解释这个问题。</p><h2 id="端序"><a href="#端序" class="headerlink" title="端序"></a>端序</h2><p>对于整数和浮点数，端序（也叫 字节序）指定了一个值的各个字节的排列方式。在大端序编码系统中，</p><p>字节的排列就跟我们在纸上写数字一样：最有标志性的的字节在前面。在小端序系统中则是最不具意义的字节在前面。在我来看，这个问题可以说上是<a href="https://en.oxforddictionaries.com/explore/what-is-the-oxford-comma/" target="_blank" rel="noopener">牛津逗号</a>的系统编程版本，该用哪种字节序并不重要，因人而异，所以这两种端序都很常见。</p><p>现在，小端序逐渐赢得了这场争夺，因为在新硬件平台上（如所有的x64芯片和大部分ARM芯片）普遍用小端序作为它们的原生格式，而大端序则被降级到仅用作为各种随机格式的存储/线路编码。</p><p>这么说来，在不知道一个平台的原生端序的情况下写程序也是很简单的事情，所以让Rust去支持其他的大端序平台也不是什么大问题。</p><h2 id="分段架构"><a href="#分段架构" class="headerlink" title="分段架构"></a>分段架构</h2><p>这里的分段架构指的是具有相同运行时表示的指针实际上指向不同的内存区域，因为它们被关联到了不同的片段。</p><p> John Regehr提供的一个例子是<a href="http://www.kjit.bme.hu/images/stories/targyak/jarmufedelzeti_rendszerek/atmel_atmega128_manual.pdf" target="_blank" rel="noopener">ATmega128</a>，它是一个有4个片段：SRAM, EEPROM, ROM和I/O的8位微处理器。</p><p>我认为分段会给编程模型增添复杂度，原因有三：</p><ul><li><p>不同片段的指针可能会有不同的属性/要求；</p></li><li><p>不同片段的指针之间如何进行比较尚不明确；</p></li><li><p>分段需要将指针大小和指针偏移大小去耦合，但是Rust目前把它们同等看待(<code>usize</code>)</p></li></ul><p>不幸的是，到这里我没有头绪了，对这些问题我只了解了皮毛。所以，我暂时不在这里讨论了，让其他人来解决吧！</p><h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>不同的人对ABI有不同的理解。到目前为止，可以说它是“为了让至少两个东西能够良好工作所需要满足的条件的实现细节”的通用术语。本文中ABI的概念涵盖类型的内存布局以及不同类型/值在C函数之间是如何传递的两方面，因为它们是Rust ABI所保证的且确实有用。</p><p>Rust的ABI目前还有一些没有规范化或不稳定的细节，如trait对象的虚函数表的排列，以及链接器/调试符号如何被拆分。如果你不知道我在说什么，也没关系，因为你现在不必关心这些内容！（但是仍有人不断尝试了解…）</p><p>无论如何，这里我想重点讲<em>调用约定**，它与ABI的参数/返回值有关。</em></p><p>为了简单起见，我只关注C语言中调用约定相关的内容，因为C语言广泛使用在流行的现代硬件和操作系统（如：x86, x64, AArch64; Mac, Windows, Linux, Android, iOS）上。这里我不会展开讨论一些基础知识，读者可能会感兴趣：</p><ul><li><p><a href="https://en.wikipedia.org/wiki/Lisp_machine" target="_blank" rel="noopener">Lisp machines</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Stack_machine" target="_blank" rel="noopener">Stack machines</a></p></li><li><p><a href="https://blog.cloudflare.com/how-stacks-are-handled-in-go/" target="_blank" rel="noopener">Segmented Stacks in Go</a></p></li><li><p><a href="https://github.com/apple/swift/blob/edfb86f09aaf8cfcc1a0608bdcd6fe21b7a35460/docs/CallingConvention.rst#responsibility">Swift’s ownership/ARC ABI</a></p></li><li><p><a href="https://quuxplusone.github.io/blog/2018/05/02/trivial-abi-101/" target="_blank" rel="noopener">Non-trivial types in C++</a></p></li></ul><h3 id="调用约定的问题和作用"><a href="#调用约定的问题和作用" class="headerlink" title="调用约定的问题和作用"></a>调用约定的问题和作用</h3><p>首先说问题：通常CPU调用一个函数也会有native概念，但是它往往比编程语言的函数调用简单得多。最简单的形式， 一个调用指令仅仅告诉CPU跳转到一个新的指令集并执行这些指令。但是我们了解的大部分编程语言中的函数都有参数，因此我们需要定义某种方式让函数调用者设置状态，以便被调用的函数能找到这些参数。函数返回值也类似，要求被调用的函数设置状态，以便函数调用者能够它中止的地方继续执行，并取得返回值。</p><p>在函数调用的调用者与被调用者之间传递状态的方法主要有两种：存在寄存器中，存在栈中。关于这两种方法孰优孰劣有大量的讨论，我没有完全理解它们，但是这里我会尝试给出一些粗略观点。</p><p><a href="https://en.wikipedia.org/wiki/Processor_register" target="_blank" rel="noopener">寄存器</a>是CPU最基本的可观察全局（线程局部）状态。它们的访问速度极快，但是通常也很小。通常CPU要完成任何事情都需要使用寄存器。CPU指令可以理解为具有自己的特殊ABI的微小内置函数，且这些ABI通常在寄存器之间传递参数/返回值。一个优秀且稳定的现代化CPU会提供大约32个64位的通用寄存器。小于1KB的工作空间！SIMD寄存器可能会增加到几KB，但是它们也还是不方便使用。更多关于寄存器工作空间大小设置的有趣细节请参考<a href="https://en.wikipedia.org/wiki/Register_renaming" target="_blank" rel="noopener">寄存器重命名</a>！</p><p>值被传递给寄存器，是真的将它们放在寄存器中！如果一个参数应该通过寄存器1被传递， 调用函数在执行调用前要保证这个参数值在寄存器1中，当被调用函数运行时就知道寄存器1保存了这个参数值。类似的，如果返回了某个值在寄存器1中，在被调用函数将控制权返回给调用函数之前，被调用函数只需确保这个值在寄存器1中。</p><p><a href="https://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">栈</a>是用RAM为线程扩展工作空间的简单抽象。栈按照比寄存器大得多的固定最大值（如今通常大约为8M）连续分配。最简单的形式，当一个函数被调用时，会先要求栈“push”足够的空间来保存所有可能需要的状态，当函数返回值，同样大小的空间会被“pop”出来。每个函数所请求的这块空间被称为<em>栈帧。</em>更多有趣的细节，请参考<a href="http://man7.org/linux/man-pages/man3/alloca.3.html" target="_blank" rel="noopener">alloca</a>和<a href="https://en.wikipedia.org/wiki/Red_zone_(computing" target="_blank" rel="noopener">the red zone</a>)。</p><p>栈帧的入栈和出栈的具体细节是另一个与调用约定相关的问题，但这里我们不展开讨论。我们只需要知道栈大小是可预测的，通过将值放在调用函数栈帧末尾或放在被调用函数栈帧的起始处，值就可以在栈中在函数之间被传递。无论那种方式，不负责保存值的函数都会假设对方的栈帧中有足够的空间保存参数或返回值，从而根据需要随意读写这块内存。</p><p>栈的工作空间大，所带来的主要问题是使用它会比寄存器更慢。即便使用现代化硬件，由于<a href="https://en.wikipedia.org/wiki/CPU_cache" target="_blank" rel="noopener">缓存</a>和<a href="https://en.wikipedia.org/wiki/Speculative_execution" target="_blank" rel="noopener">推测执行</a>等技术的存在，这是一个复杂的问题。无论如何，我们假设将内容保存在栈和寄存器中都是理想的，继续我们的讨论。</p><p>另请注意，为了避免将很大的值拷贝到寄存器或栈中，可能会传递一个指向这个值（无论是在栈还是在寄存器中）的<em>指针，</em>尽管函数声明可能要求按值传递。这个策略在一个很大的值被多个函数调用使用的情况下尤其有效。</p><p>理解调用约定我们需要记住的最后一件事情是我们的约束。我们需要ABI在完全<em>静态</em>或<em>动态</em>的上下文中工作。也就是说，调用函数和被调用函数唯一都知道的内容只有被调用函数的函数签名。为了在调用函数之间共享被调用函数的实现（如虚函数表或<a href="https://en.wikipedia.org/wiki/Dynamic_linker" target="_blank" rel="noopener">动态链接</a>），任何其他函数也应该可以调用这个被调用函数。</p><p>在我们开始讨论传参问题之前，现在我们已知的内容会导致一个冲突：两个函数都想尽可能的使用寄存器以更快地执行，两个函数都是用相同的寄存器，且它们都不知道对方正在用哪一个寄存器！</p><p>有一个很简单（糟糕）的解决方案：在被调用函数的开始处将所有寄存器状态保存到栈，然后当被调用函数准备返回时，从栈中恢复所有的寄存器状态。我们把被调用函数保存寄存器的方案叫做<em>被调用者保存</em>或<em>不可变寄存器。</em>这个方案非常糟糕，因为寄存器非常大！将所有数据拷贝到栈或从栈中取出需要花费很多时间。我们有更好的方案。（总的来说：这正是<a href="https://en.wikipedia.org/wiki/Context_switch" target="_blank" rel="noopener">上下文切换</a>的工作原理，尽管操作系统采取了一些trick来避免总是要保存/恢复所有的寄存器。）</p><p>一个稍微好的方案是：在即将要执行调用之前，调用将它真正关心的寄存器保存到栈，然后被调用函数就可以随意使用寄存器了，而调用函数会认为被调用函数使用过所有的寄存器，并在合适的时候重新初始化这些寄存器。这个方案叫做<em>调用者保存</em>或<em>可变寄存器。</em>默认情况下，这个方案更好，因为调用者通常不会使用太多寄存器（特别是大部分寄存器大小是比较难用的SIMD）。这个方案的另一个好处是它释放了所有的寄存器，它们都可以用来传参/返回值！</p><p>现代的调用约定通常采用一种基于传统方案的混合方案。某些寄存器被标记为被调用这保存，而另外一些被标记为调用者保存。这让调用者和被调用者具有协同避免寄存器保存的灵活性。</p><p>例如，如果调用者将它所有的工作集都保存在不可变寄存器中而被调用者将它的所有工作集保存在可变寄存器中，那么根本就不需要保存寄存器。这就给保留<em>几个</em>被调用者保存寄存器一个合理的理由。类似的，被调用者保存也可以用于需要传递给许多函数“上下文”指针的代码（如：大部分语言中的<code>this/self</code>，以及几个该死的C框架）。</p><h3 id="几个关于调用约定的例子"><a href="#几个关于调用约定的例子" class="headerlink" title="几个关于调用约定的例子"></a>几个关于调用约定的例子</h3><p>这里不在讨论调用约定的完整细节了，我将主要关注前文中述及的不同点是如何影响不同约定的表现行为的。看几个System V ABI给<a href="https://www.uclibc.org/docs/psABI-i386.pdf#section.2.2" target="_blank" rel="noopener">x86</a>（“cdecl”）和<a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf#section.3.2" target="_blank" rel="noopener">x64</a>传值的例子（尽管x86有点杂乱，这些都是标准的Linux/BSD/MacOS调用约定，所以这里我们假定是Linux上的GCC，希望它具有共通性）。</p><p>关于符号的注解：<code>stack -x</code>表示这个值在被调用函数的栈帧之前保存了<code>x</code>字节（因为System V ABIs将栈参数保存在调用者中）。</p><p>有如下声明：</p><pre><code class="rust">struct Meter {int32_t len; }struct Point { int32_t x; int32_t y; };int32_t process(void* a, float b, struct Meter c, struct Point d);</code></pre><p>可以得到下列的底层描述：</p><pre><code class="rust">process (x86 System V):a           void*:  stack -4b           float:  stack -8c         {int32}:  stack -12d  {int32, int32}:  stack -20----------------------------------return      int32:  register eaxprocess (x64 System V):a           void*:  register rdib           float:  register xmm0c         {int32}:  register rsid  {int32, int32}:  register rdx----------------------------------return      int32:  register rax</code></pre><p>可以看到老ABI大部分时候只是在栈上传递值，而新ABI则更多地在寄存器中传递值。注意<code>float b</code>参数被传递到了<code>xmm</code>寄存器，而不是通用寄存器<code>r</code>，这是因为浮点数和整数被区别对待（鼓励将两者区分对待）。</p><p>x86 ABI处理返回值的方式鼓励区分组合类型和基本类型。如果改变<code>process</code>返回<code>Meter</code>，会得到如下的底层描述：</p><pre><code class="rust">process (x86 System V):return    {int32}:  stack -4a           void*:  stack -8b           float:  stack -12c         {int32}:  stack -16d  {int32, int32}:  stack -24----------------------------------return   {int32}*:  register eax (pointer to stack -4)process (x64 System V)a           void*:  register rdib           float:  register xmm0c         {int32}:  register rsid  {int32, int32}:  register rdx----------------------------------return    {int32}:  register rax</code></pre><p>虽然类型的布局是完全相同的，但是x86 ABI总是隐式地将结构体和组合类型作为第一个参数传递到栈上。x64 ABI“修复”了这个问题，将这两者视为等同。</p><p>然而x64 ABI处理复合类型的按值传递非常复杂。考虑如下两个声明：</p><pre><code class="rust">struct Ints         { int32_t a; int32_t b; int32_t c; int32_t d; };struct IntAndFloats { int32_t a;   float b;   float c;   float d; };void process1(struct Ints vals);void process2(struct IntAndFloats vals);</code></pre><pre><code>process1 (x64 System V)(vals.a, vals.b):  register rdi(vals.c, vals.d):  register rsiprocess2 (x64 System V)(vals.a, vals.b):  register rdi(vals.c, vals.d):  register xmm0</code></pre><p>x64 ABI将结构体拆分成8字节的块并对字段做递归分类。在这种情况下，可以看到<code>IntAndFloats</code>的前半部分中整数<code>a</code>比浮点数<code>b</code>的“比重更大”，所以这个块被传递到了通用寄存器。而第二个块完全由浮点数组成，因此被传递到了<code>xmm0</code>。这表明，如果想正确地将一个组合类型传递给x64 ABI，我们需要知道该类型所有字段的精确ABI。</p>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jest玩转异步代码测试</title>
      <link href="/2018/08/25/ts-jest/"/>
      <url>/2018/08/25/ts-jest/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在软件开发中，我们通常通过单元测试（Unit Test, UT）来确保编写的代码符合软件需求，UT也往往作为自动化集成的一部分存在于软件工程中。说来惭愧，笔者在过去的工作中没有写过UT，最近主动接受了为项目做UT的任务，以弥补这方面的经验不足。本文主要介绍使用Jest对TypeScript项目中异步代码做UT的一些实践。</p></blockquote><a id="more"></a><h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p><a href="https://jestjs.io/" target="_blank" rel="noopener">Jest</a>是一个优秀的JS代码测试框架，它能够对几乎所有的JS代码进行测试，尤其是<code>React</code>(毕竟都是FB爸爸的亲儿子)。</p><p>选择Jest来做UT主要是因为它具有以下几个特点：</p><ul><li>开箱即用，几乎零配置集成到项目中；</li><li>测试运行速度快，反馈及时；</li><li>丰富的mock接口，可以mock模块、类、同步代码、异步代码等几乎所有常见的测试场景。</li></ul><p>更多关于Jest的介绍及其API文档请参阅<a href="https://jestjs.io/" target="_blank" rel="noopener">官方文档</a>。下面直接进入正题。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>安装jest依赖，这里需要额外安装<code>ts-jest</code>和<code>@types/jest</code>两个依赖包来支持TS。</p><pre><code class="js">yarn add --dev jest ts-jest @types/jest</code></pre></li><li><p>在项目根目录添加<code>jest.config.js</code>文件，作为jest的配置文件，jest会根据该文件中的配置来执行测试任务，如指定测试文件所在的目录、是否需要收集覆盖率信息等。配置文件一般长这样：</p><pre><code class="js">module.exports = {transform: {&#39;^.+\\.tsx?$&#39;: &#39;ts-jest&#39;},testMatch: [&#39;**/__tests__/**/?(*.)+(spec|test).(js|ts)?(x)&#39;],testPathIgnorePatterns: [&#39;/node_modules/&#39;, &#39;lib/&#39;],moduleFileExtensions: [&#39;ts&#39;, &#39;tsx&#39;, &#39;js&#39;, &#39;jsx&#39;, &#39;json&#39;, &#39;node&#39;],verbose: true,bail: true,collectCoverage: true,collectCoverageFrom: [&#39;src/*.ts&#39;],coverageDirectory: &#39;__tests__/coverage/&#39;}</code></pre></li><li><p>设置test任务执行入口 —— 在<code>package.json</code>中添加如下命令，便可以通过<code>yarn test</code>执行测试任务。</p><pre><code class="json">&quot;scripts&quot;: {&quot;test&quot;: &quot;jest&quot;}</code></pre></li></ol><p>完成上述准备工作后，我们就可以愉快地开始写test case了。</p><h2 id="Test-case"><a href="#Test-case" class="headerlink" title="Test case"></a>Test case</h2><p>为了便于文件的组织管理，我们将所有的包含test case的文件都放在<code>__tests__</code>文件夹下。</p><p>一个典型的测试文件（以<code>index.spec.ts</code>为例）应该长成这样：</p><pre><code class="typescript">describe(&#39;Test index&#39;, () =&gt; {  it(&#39;test case 1&#39;, () =&gt; {    const tmp = &#39;123&#39;;    expect(tmp).toBe(&#39;123);  });  it(&#39;test case 2&#39;, () =&gt; {    const tmp = &#39;456&#39;;    expect(tmp).toBe(&#39;456);  });  // ...});</code></pre><p>其中<code>describe</code>表示一个测试集，每个<code>it</code>表示一个test case。<code>expect</code>语句用于断言该条测试是否通过，一个test case中可以有任意多个<code>expect</code>语句，只有所有断言都为真，该test case才通过。</p><p>下面我们借由一个测试类的例子来熟悉如何使用jest书写test case。</p><p>在测试类的时候，一般需要测试某个对象是否是该类的实例，类的创建实例的时候是否执行了构造函数中的某些代码等等。<br><code>jest</code>提供了几个api来满足上述需求：</p><ul><li><code>beforeEach</code>：当前测试集<code>describe</code>范围内，定义在每个test case执行前执行的代码，常用于执行一些初始化工作</li><li><code>.toBeInstanceOf()</code>：检查某个对象是某个类的实例</li><li><code>jest.spyOn(Object, method)</code>：为对象上的某个方法创建一个mock函数，并track该方法</li><li><code>.toHaveBeenCalledWith(params)</code>和<code>toHaveBeenCalled()</code>：检查某个方法是否被调用</li></ul><p>代码简易实现如下：</p><pre><code class="typescript">describe(&#39;Test Service Class&#39;, () =&gt; {  let service: Service;  beforeEach(() =&gt; {    // 每个test case前都new一个实例    service = new Service(serviceConfig);  });  it(&#39;Service constructor has been called&#39;, () =&gt; {    // new出来的实例service应该是Service的实例    expect(service).toBeInstanceOf(Service);  });  it(&#39;Service startup and shutdown normally&#39;, async () =&gt; {    // track service实例上的startup和shutdown方法    // 当他们被调用的时候，jest就能追踪到    const startup = jest.spyOn(service, &#39;startup&#39;);    const shutdown = jest.spyOn(service, &#39;shutdown&#39;);    // 手动调用service的startup方法    await service.startup(startupConfig);    // startup方法应该被调用了，且传入的参数为startupConfig    expect(startup).toHaveBeenCalledWith(startupConfig);    service.shutdown();    // shutdown方法应该被调用了    expect(shutdown).toHaveBeenCalled();  });});</code></pre><p>读者可能已经注意到了，在第二个test case中，我们使用了<code>async/await</code>语法。<br>这其实是jest支持测试异步代码的一种写法，下面主要介绍如何用jest测试异步代码，因为这也是JS的UT中最主要的部分。</p><h2 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h2><p>我们知道，JS世界里充满了异步代码。<br>正常情况下测试代码是同步执行的，但当我们待测的代码是异步的时候，就会有问题了，会导致test case已经结束了，但是我们的异步代码并没有执行，从而导致异步代码没有被测到。那怎么办呢？<br>对于当前test case来说，异步代码什么时候执行它并不知道，因此解决方法很简单。当有异步代码的时候，test case跑完同步代码后不立即结束，而是等结束的通知，当异步代码执行完后再告诉jest：“好了，异步代码执行完了，你可以结束任务了”。</p><p>jest提供了三种方案来测试异步代码，下面我们分别来看一下。</p><h3 id="done关键字"><a href="#done关键字" class="headerlink" title="done关键字"></a><code>done</code>关键字</h3><p>当我们的test函数中出现了异步回调函数时，可以给test函数传入一个<code>done</code>参数，它是一个函数类型的参数。如果test函数传入了<code>done</code>，jest就会等到<code>done</code>被调用才会结束当前的test case，如果<code>done</code>没有被调用，则该test自动不通过测试。</p><pre><code class="js">it(&#39;Test async code with done&#39;, (done) =&gt; {  setTimeout(() =&gt; {    // expect something    done();  }, 0)});</code></pre><p>上面的代码中，我们给test函数传入了<code>done</code>参数，在<code>setTimeout</code>的回调函数中调用了<code>done</code>。这样，setTimeout的回调中异步执行的测试代码就能够被执行。</p><h3 id="返回Promise"><a href="#返回Promise" class="headerlink" title="返回Promise"></a>返回Promise</h3><p>如果代码中使用了<code>Promise</code>，则可以通过返回<code>Promise</code>来处理异步代码，jest会等该promise的状态转为<code>resolve</code>时才会结束，如果promise被<code>reject</code>了，则该test不通过。</p><pre><code class="js">// 假设 doAsync() 返回一个promise，resolve的结果为字符串&#39;example&#39;it(&#39;Test async code with promise&#39;, () =&gt; {  expect.assertions(1);  return doAsync().then((data) =&gt; {    expect(data).toBe(&#39;example&#39;);  });});it(&#39;Test promise with an error&#39;, () =&gt; {  expect.assertions(1);  return doAsync().catch(e =&gt; expect(e).toMatch(&#39;error&#39;));});</code></pre><p>注意，上面的第二个test可用于测试promise返回reject的情况。这里用<code>.catch</code>来捕获promise返回的reject，当promise返回reject时，才会执行expect语句。而这里的<code>expect.assertions(1)</code>用于确保该test中有一个expect被执行了。</p><p>对于<code>Promise</code>的情况，jest还提供了一对匹配符<code>resolves/rejects</code>，其实只是上面写法的语法糖。上面的代码用匹配符可以改写为：</p><pre><code class="js">// 假设 doAsync() 返回一个promise，resolve的结果为字符串&#39;example&#39;it(&#39;Test async code with promise&#39;, () =&gt; {  expect.assertions(1);  return expect(doAsync()).resolves.toBe(&#39;example&#39;);  });});it(&#39;Test promise with an error&#39;, () =&gt; {  expect.assertions(1);  return expect(doAsync()).rejects.toMatch(&#39;error&#39;));});</code></pre><h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>我们知道使用<code>async/await</code>其实是<code>Promise</code>的语法糖，可以更优雅地写异步代码，jest当然也支持这种语法。下面我们看一下上面例子的<code>async/await</code>版本实现。</p><pre><code class="js">// 假设 doAsync() 返回一个promise，resolve的结果为字符串&#39;example&#39;it(&#39;Test async code with promise&#39;, async () =&gt; {  expect.assertions(1);  const data = await doAsync();  expect(data).toBe(&#39;example&#39;);  });});</code></pre><p><code>async/await</code>也可以和<code>resolves/rejects</code>一起使用：</p><pre><code class="js">// 假设 doAsync() 返回一个promise，resolve的结果为字符串&#39;example&#39;it(&#39;Test async code with promise&#39;, async () =&gt; {  expect.assertions(1);  await expect(doAsync()).resolves.toBe(&#39;example&#39;);  });});</code></pre><p>上面这几种异步测试代码的写法其实没有孰优孰劣之分，读者应视使用场景而决定用那种方式，毕竟我们的目标总是希望更优雅而简单地写test case。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从实践出发，首先简单介绍了<code>jest</code>及将其集成到typescript项目中需要做的准备工作，然后通过两个案例讲解了如何用jest写UT和UT集。在实践中，测试JS异步代码是非常常见的场景，本文详细讲解了jest中编写异步代码测试用例的3种主要方式。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://jestjs.io/" target="_blank" rel="noopener">Jest官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于Vue的跨区域拖拽方案实现</title>
      <link href="/2018/07/06/vue-dragarea/"/>
      <url>/2018/07/06/vue-dragarea/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据驱动是Vue的核心思想之一，Vue官方也鼓励使用数据驱动思想进行开发，这样可以有效利用Vue的diff算法提升性能。拖拽是前端开发中一种常见的交互形式，本文介绍一种利用Vue的数据驱动特性和双向绑定能力实现的跨区域拖拽方案(兼容IE9+)。</p></blockquote><a id="more"></a><h2 id="设计方案"><a href="#设计方案" class="headerlink" title="设计方案"></a>设计方案</h2><h4 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h4><p>首先考虑到需要兼容IE9，因此不能使用现代浏览器原生支持的<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener">HTML Drag and Drop API</a>，而改用<code>mousedown</code>、<code>mousemove</code>和<code>mouseup</code>的组合来模拟拖拽操作。</p><p>模拟拖拽的思路其实很简单，在组件上注册<code>mousedown</code>事件的回调，并在回调函数中将<code>mousemove</code>和<code>mouseup</code>事件注册到<code>document</code>上，在它们各自的回调函数中分别处理中间态处理和drop操作，代码示例如下：</p><p><strong>注：注册的事件一定要记得注销，否则可能会造成内存泄露。</strong></p><pre><code class="js">mounted() {    on(this.$el, &#39;mousedown&#39;, this.mouseDown, false);},methods: {    mouseDown(e) {        on(document, &#39;mousemove&#39;, this.mouseMove);        on(document, &#39;mouseup&#39;, this.mouseUp);        // 初始化    },    mouseMove(e) {        // 处理拖拽中间态    },    mouseup(e) {        this.offEvents;        // 执行或取消 drop 操作    },    offEvents() {        off(document, &#39;mousemove&#39;, this.mouseMove);        off(document, &#39;mouseup&#39;, this.mouseUp);    }}beforeDestroy() {    this.offEvents();    off(this.$el, &#39;mousedown&#39;, this.mouseDown, false);}</code></pre><h4 id="拖拽中间态处理"><a href="#拖拽中间态处理" class="headerlink" title="拖拽中间态处理"></a>拖拽中间态处理</h4><p>当我们拖动鼠标开始拖拽的时候，需要在<code>mousemove</code>的回调中有3个中间态需要处理：</p><ul><li>更新被拖拽的节点的位置</li><li>计算拖拽节点hover在哪个节点上（即图中的<code>dropInfo</code>，用于表示插入位置，详见后文）。</li><li>为了支持跨区域拖拽，需要将当前dragarea内的<code>dropInfo</code>状态同步到其他dragarea内，这里使用<code>eventBus</code>来实现组件间的通信，详见后文。</li></ul><div style="text-align: center;"><img src="/assets/img/mouseMove.png" alt="拖拽中间态"></div><h4 id="执行drop操作"><a href="#执行drop操作" class="headerlink" title="执行drop操作"></a>执行drop操作</h4><p>拖拽结束时，要做的事情就是在<code>mouseup</code>的回调中执行或取消drop操作，判断逻辑如下：</p><div style="text-align: center;"><img src="/assets/img/mouseUp.png" alt="drop操作"></div><h2 id="难点及解决方案"><a href="#难点及解决方案" class="headerlink" title="难点及解决方案"></a>难点及解决方案</h2><p>了解了整体的设计思路后，我们来看一下实践过程中遇到的一些难点及解决方案。</p><h4 id="难点一：drop位置的确定"><a href="#难点一：drop位置的确定" class="headerlink" title="难点一：drop位置的确定"></a>难点一：drop位置的确定</h4><p>前文有提到，我们通过<code>dropInfo</code>来确定插入的位置，它包含两个字段：</p><ul><li>dropItemId:    作为参考的drag-item的id</li><li>insertType：1表示在参考drag-item之前插入，表示参考drag-item之后插入</li></ul><p>那么我们怎么才能计算出这两个字段的值呢？</p><p>首先，我们考虑如何得到dropItemId的值。</p><p>这里先介绍一个强大的API：<a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/elementFromPoint" target="_blank" rel="noopener"><code>document.elementFromPoint</code></a>，用它可以获得相对<code>viewport</code>指定坐标位置处最顶层的DOM节点。</p><p>若将drag-item的id作为属性绑定在其DOM上，借助这个API，找到drag-item，也就就得到dropItemId了：</p><p>1、用当前鼠标位置拿到最顶层的DOM</p><pre><code class="js">getUnderneathNode(x, y) {    // 先将dragging item设置为none    // 以便elementFromPoint能拿到拖拽结束时鼠标位置处的最顶层DOM节点    addClass(this.$srcNode, &#39;is-hidden&#39;);    let target = document.elementFromPoint(x, y);    removeClass(this.$srcNode, &#39;is-hidden&#39;);    return target || null;},</code></pre><p>2、递归找到当前DOM节点所属的v-drag-item</p><pre><code class="js">/*** 根据targetClass找到目标DOM节点* @param {Element} eTarget 源事件DOM节点* @param {String} targetClass 具有标记的类名* @return {Element | null} 返回找到的DOM节点或null*/findTargetNode(eTarget, targetClass = ITEM_CLASS) {    if (eTarget.className &amp;&amp; hasClass(eTarget, targetClass)) {        return eTarget;    }    let parent = eTarget.parentNode;    if (parent) {        return this.findTargetNode(parent, targetClass);    }    return null;},</code></pre><p>3、获取DOM节点上的id</p><pre><code class="js">getItemId(target) {    return target.getAttribute(&#39;data-id&#39;) || &#39;&#39;;}</code></pre><p>接下来，我们需要通过碰撞热区来确定<code>insertType</code>的值。</p><p>本组件支持通过自定义类名来定义热区的大小，实现的方法是在真实拖拽节点外面包一层节点，因此一个<code>v-drag-item</code>的DOM结构如下：</p><div style="text-align: center;"><img src="/assets/img/drag-item.png" alt="drag-item"></div><p>我们根据类名<code>v-drag-item__inner</code>来找拖拽节点，而在计算碰撞区域的时候则用类名<code>v-drag-item</code>。</p><div style="text-align: center;"><img src="/assets/img/drag-item-hotarea.png" alt="碰撞热区"></div><p>若鼠标位置落在<code>v-drag-item</code>的上半部分，则<code>insertType</code>为1，反之则为2。</p><h4 id="难点二：-滚动处理"><a href="#难点二：-滚动处理" class="headerlink" title="难点二： 滚动处理"></a>难点二： 滚动处理</h4><p>在拖拽过程中，如果<code>v-dragarea</code>或其父容器有滚动条，那么在某些情况下可能需要在拖到容器底部的时候滚动条自动向下滚动，拖动到顶部的时候则向上滚动。为了实现这个效果，需要在<code>mousemove</code>的回调中多做一个逻辑处理。</p><pre><code class="js">// 只有开启了自动滚动时才处理if (this.useAutoScroll) {    // 获取设置了overflow: scroll的父容器    const scrollParent = getScrollParent(this.$el);    // 若父容器存在且出现了可见的滚动条    if (scrollParent &amp;&amp; hasScrollbar(scrollParent)) {        // 计算滚动方向        const direction = this.getScrollDirection(scrollParent);        // 执行滚动        direction &amp;&amp; this.scrollContainer(scrollParent, direction);    }}</code></pre><p>下面的函数可以用来判断一个元素是否真的有可见的滚动条：</p><pre><code class="js">/** * 判断指定element元素是否有滚动条 * @param {Element} element 指定的元素 * @param {String} direction 滚动条方向，默认为垂直方向 * @return {Boolean} 是否有滚动条 */function hasScrollbar(element, direction = &#39;vertical&#39;) {    if (direction === &#39;vertical&#39;) {        return element.scrollHeight &gt; element.clientHeight;    }    return element.scrollWidth &gt; element.clientWidth;}</code></pre><p>滚动方向的判断：</p><pre><code class="js">/*** 根据越界的边界判断滚动条的滚动方向* @param {Element} scrollParent 有滚动条的父容器* @return {String} 滚动方向，不越界或滚动条已无法滚动则返回空字符串*/getScrollDirection(scrollParent) {    const containerRect = getRect(scrollParent);    const srcNodeRect = getRect(this.$srcNode);    const step = this.scrollStep;    // 被拖拽的item快到底部了且滚动条还没到底部，则滚动方向为bottom    if (srcNodeRect.top + srcNodeRect.height + step &gt; containerRect.top + containerRect.height        &amp;&amp; scrollParent.scrollHeight &gt; scrollParent.clientHeight + scrollParent.scrollTop) {        return &#39;bottom&#39;;    }    // 被拖拽的item快到顶部了且滚动条还没到顶部，则滚动方向为top    if (srcNodeRect.top - step &lt; containerRect.top &amp;&amp; scrollParent.scrollTop &gt; 0) {        return &#39;top&#39;;    }    return &#39;&#39;;}</code></pre><h4 id="难点三：-跨区域状态同步"><a href="#难点三：-跨区域状态同步" class="headerlink" title="难点三： 跨区域状态同步"></a>难点三： 跨区域状态同步</h4><p>在多<code>dragarea</code>之间拖拽的时候，需要将<code>dropInfo</code>中间态从当前<code>dragarea</code>同步到其他<code>dragarea</code>，这样才可以在其他<code>dragarea</code>中拿到当前drop位置，并判断是否出现待drop的样式。</p><p>这种情况是典型的兄弟组件或父子组件间的通信，因此可以用<code>eventBus</code>来实现，代码如下：</p><pre><code class="js">methods: {    mouseMove(e) {        // 其他逻辑处理        eventBus.$emit(            VHTML_DRAGEAREA_DROPINFO_UPDATE,            {dropAreaId, dropItemId, insertType}        );    }，    updateDropInfo(val) {        if (this.allowDrop) {            let dropItemId = &#39;&#39;;            let insertType = INSERT_AFTER;            // 只有目标drop区域是当前dragarea的时候才更新            if (val.dropAreaId === this.areaId) {                dropItemId = val.dropItemId;                insertType = val.insertType;            }            this.dropItemId = dropItemId;            this.insertType = insertType;        }    }}，created() {    eventBus.$on(VHTML_DRAGEAREA_DROPINFO_UPDATE, this.updateDropInfo);},beforeDestroy() {    eventBus.$off(VHTML_DRAGEAREA_DROPINFO_UPDATE, this.updateDropInfo);}</code></pre><p>每个<code>dragarea</code>中都会监听<code>eventBus</code>上的<code>VHTML_DRAGEAREA_DROPINFO_UPDATE</code>事件，同时会在<code>mousemove</code>回调中触发该事件，这样一来，每个<code>dragarea</code>的<code>dropInfo</code>状态都会同步到所有的<code>dragarea</code>中。对于每个<code>dragarea</code>，只有目标drop区域是当前<code>dragarea</code>的时候才更新<code>dropInfo</code>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>跨区域拖拽组件从交互和实现角度来说，都可以说是基础组件中比较复杂的一种。一图胜千言，最后展示一下基于本文方案实现的拖拽组件demo：</p><div style="text-align: center;"><img src="/assets/img/drag-demo.gif" alt="drag-demo"></div>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
            <tag> drag </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue中使用Provide/Inject实现全局浮层管理</title>
      <link href="/2018/02/04/vue-provide-inject/"/>
      <url>/2018/02/04/vue-provide-inject/</url>
      
        <content type="html"><![CDATA[<blockquote><p>  在基于Vue构建大型应用时，不可避免地需要在不同层级的组件之间进行通信，Vue提供了<code>props/event</code>、<code>event bus</code>、<code>Vuex</code>、<code>provide/inject</code>等方式来实现组件间通信。本文将阐述一种基于provide/inject来统一管理组件库中各类弹窗组件的思路。</p></blockquote><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>最近的一个项目中，有这样一个业务场景：webview页面运行在客户端提供的容器（浏览器）内，当webview中有浮层出现时，需要拿到这个浮层的大小和位置等信息进行计算，并通知客户端调整容器内显示的内容，交互形式如下图所示。</p><div style="text-align: center;"><img src="/assets/img/webview_AIO.png" alt="webview_AIO"></div><p>我们项目中使用了团队自主开发的公司内部开源组件库<a href="https://github.com/0067ED/vhtml">vhtml</a>，目前vhtml有popper、dialog、pannel、contextmenu等常用浮层类组件（下文统称为<code>overlay</code>）。根据需求，每当有一个浮层出现时，都要知道这个浮层是谁，它的大小是多少，当前出现在webview页面上的哪个位置。在实际业务应用中，浮层类组件的大小、在页面组件树中的层级和数量都是不可预知的，甚至经常会出现嵌套使用的场景。那么在这种情况下，我们怎么才能知道现在webview页面中哪些浮层组件是打开的，哪些是关闭的呢？换句话说，这种情况下该如何进行组件间通信呢？答案就是provide/inject。</p><h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h3><p>Vue从2.2.0开始加入了<a href="https://vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener">provide/inject</a>这对好兄弟，它们主要应用于高阶插件/组件库，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。可见，provide/inject正是解决我们问题的最佳方案，因为它们就是为这种场景而设计的啊！</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><p>我们的目标是拿到页面中所有打开的overlay。现在，让我们换一种思路——我们不主动去“获取”每个overlay的状态，而是让每个overlay在改变自己的开闭状态时主动通知“管理员”：“嗨，我打开（或关闭）了”。</p><p>使用<code>provide/inject</code>，我们就可以在overlay与“管理员”之间建立联系：</p><div style="text-align: center;"><img src="/assets/img/vue_provide_inject.png" alt="vue_project_inject"></div><ol><li>在页面组件树的根组件（本文中是App.vue）上<code>provide</code>一个回调函数(暂叫updateCallback)</li><li>在每个overlay组件内<code>inject</code>这个回调函数，当该overlay组件在打开或关闭时，都调用这个回调函数，并将组件的信息（如key、postion等）传递给回调函数。</li><li>在回调函数里统一维护overlay组件的状态及其信息。</li></ol><h3 id="怎么写"><a href="#怎么写" class="headerlink" title="怎么写"></a>怎么写</h3><p>下面我们看看具体的代码实现。</p><p>首先，我们需要在<code>App.vue</code>中<code>provide</code>选项中定义我们的回调函数，该函数应具有统一处理所有overlay的功能。在我们的项目中，我们使用RxJS来实现数据层，关于RxJS的知识这里不赘述，感兴趣的读者可以去<a href="http://reactivex.io/rxjs/" target="_blank" rel="noopener">RxJS官网</a>了解。</p><pre><code class="javascript">@Provide(&#39;vhtmlOverlayUpdate&#39;)vhtmlOverlayUpdate(key: string, data?: OverlayRect) {    this.$dispatch(&#39;native:updateOverlay&#39;, {        key: key,        data: data    });}</code></pre><p>这里，我们的回调函数做的事情很简单，就是将overlay传来的数据分发到我们事先定义好的数据流(也就是这里的native:updateOverlay)，在数据流里处理overlays的逻辑。这样做的好处是视图层和数据层可以很好的解耦，视图层负责处理页面渲染相关的逻辑，而相对较重的业务逻辑放在数据层做，这也是我们引入RxJS构建数据层的目的。关于overlays的处理逻辑见后文。</p><p>接下来，在每个overlay组件内通过<code>inject</code>将定义好的回调函数注入到组件中，可以封装成<code>mixin</code>引入到overlay组件中。</p><pre><code class="javascript">// mixin文件: overlay.js // 用于生成唯一id的工具函数import uuid from &#39;vhtml-ui/src/utils/uuid&#39;;// 用一个不容易冲突的key和cb的名字const VHTML_ANCIENT_OVERLAY_KEYS = &#39;VHTML_ANCIENT_OVERLAY_KEYS&#39;;const VHTML_OVERLAY_CB = &#39;vhtmlOverlayUpdate&#39;;export default {    inject: {        // 注入overlay变化时的回调函数，用于抛出overlay的位置信息和key值        [VHTML_OVERLAY_CB]: {            default: null        }    },    data() {        const key = `${uuid()}_${Date.now().toString(36)}`;        return {            overlayKey: key        };    }}</code></pre><p>在mixin文件<code>overlay.js</code>中，通过<code>inject</code>注入了<code>vhtmlOverlayUpdate</code>，也就是从<code>App.vue</code> provide的回调函数。同时，也为每个overlay组件的生成了一个唯一的key，用于标识该overlay。</p><p>这里用到了Vue从2.5.0+开始加入的新特性：支持给<code>inject</code>的变量指定默认值。因此，当我们没有从父组件provide<code>vhtmlOverlayUpdate</code>变量时，就用它的默认值：<code>null</code>。</p><p>现在我们就可以在overlay组件里面拿到注入的回调函数和组件的key值了，overlay组件在<code>show</code>或<code>hide</code>的时候，执行下列代码，就可以将组件的key和position信息通过回调函数抛给数据流了。</p><pre><code class="javascript">// 该方法用于统一管理浮层if (typeof this.vhtmlOverlayUpdate === &#39;function&#39;) {    this.vhtmlOverlayUpdate(this.overlayKey, isOpen ? getRect(this.$el) : undefined);}</code></pre><p><strong>注</strong>: 为了统一用一个接口，当打开时传入回调函数的第二个参数为组件的位置信息，而关闭时则为<code>undefined</code>。</p><p>最后，我们维护了一个overlays数组用于保存当前打开的所有overlays，当有overlay有更新时，传入根据参数key和data对overlays数组进行增删改，最后将overlays数组通过流的方式被视图层订阅，视图层便拿到了当前页面中所有打开的overlay和他们的位置信息。</p><pre><code class="javascript">updateOverlays(acc: OverlayInfo[], val: OverlayInfo) {    const key = val.key;    const data = val.data;    const overlays: OverlayInfo[] = [...acc];    const curr = overlays.findIndex((item: OverlayInfo) =&gt; item.key === key);    // 当前overlay已存在于已有overlays中    if (curr !== -1) {        // 更新位置信息        if (data) {            overlays[curr].data = data;        }        // 没有data表示关闭，则从overlays中删除        else {            overlays.splice(curr, 1);        }    }    // 当前overlay还未保存于overlays中，则新增    else if (data) {        overlays.push({            key: key,            data: data        });    }    return overlays;}</code></pre><p><strong>注</strong>: 数据流部分涉及RxJS的知识，不是本文的重点，此处不述。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了一个利用provide/inject对组件库中所有浮层组件实现统一管理的方案。对于业务较复杂的组件间通信，provide/inject是一个很好的方案，它适用于组件层次深、组件多但有一定的收拢性的场景。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>项目中的代码规范检查</title>
      <link href="/2017/07/31/project-specification/"/>
      <url>/2017/07/31/project-specification/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在团队项目开发中，每个人有不同的编程习惯，包括使用不同的缩进、换行、注释等等，当团队人员逐渐增多之后，代码就会变得越来越来杂乱，这无形中给团队合作增加了困难。因此，制订一套团队的代码规范十分有必要，这套规范应该包含代码风格规范、commit规范、变量术语规范等几个方面。当然有了规范之后，为保证大家严格按照规范来进行开发，需要设置一定的“关卡”来校验这些规范，只有符合规范的代码才能通过。本文介绍利用ESlint+Git来控制项目代码的质量。</p></blockquote><a id="more"></a><h2 id="ESlint简介"><a href="#ESlint简介" class="headerlink" title="ESlint简介"></a>ESlint简介</h2><p><a href="http://eslint.org/" target="_blank" rel="noopener">ESlint</a>和<a href="https://git-scm.com/docs" target="_blank" rel="noopener">Git</a>是实现这套方案的核心工具。</p><p>ESlint是一个插件化的JS和JSX代码检查工具，它可以用于检查常见的JavaScript语法错误，也可以进行代码风格检查。<br>通过命令：<code>$ npm install --save-dev eslint</code>在项目中安装好eslint，我们可以根据自己的项目需求编写自己的ESlint配置文件<code>.eslintrc</code>，将此文件至于项目根目录即可。<br>一个简单的ESlint配置如下：</p><pre><code class="json">{    &quot;env&quot;: {        &quot;mocha&quot;: true,        &quot;es6&quot;: true,        &quot;node&quot;: true    },    &quot;globals&quot;: {        &quot;document&quot;: false,        &quot;navigator&quot;: false,        &quot;window&quot;: true    },    &quot;plugins&quot;: [&quot;vue&quot;],    &quot;parserOptions&quot;: {        &quot;ecmaVersion&quot;: 6,        &quot;sourceType&quot;: &quot;module&quot;,        &quot;ecmaFeatures&quot;: {            &quot;experimentalObjectRestSpread&quot;: true,            &quot;jsx&quot;: true        }    },    &quot;rules&quot;: {        &quot;accessor-pairs&quot;: 2,        &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],        &quot;arrow-spacing&quot;: [2, { &quot;before&quot;: true, &quot;after&quot;: true }],        &quot;brace-style&quot;: [1, &quot;stroustrup&quot;, {}],        &quot;curly&quot;: [2, &quot;multi-line&quot;],        &quot;keyword-spacing&quot;: 2,        &quot;max-depth&quot;: [1, 6],        &quot;max-len&quot;: [2, 120, 4, {            &quot;ignoreUrls&quot;: true,            &quot;ignoreComments&quot;: true,            &quot;ignorePattern&quot;: &quot;\\+ [\\w\\W]+&gt;&#39;&quot;        }],    }}</code></pre><p>具体的配置规则请参考<a href="http://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">官方配置文档</a>，这里不再赘述。</p><p>配置好ESlint之后，我们有两种方式来使用它，一种是通过命令行的方式：<code>$ eslint index.js</code>，这个命令会根据配置的eslint规则对index.js检查，如果index.jx中有不符合规则的地方，会在控制台输出错误提示（有<code>error</code>/<code>warning</code>两种）及错误所处的文件位置。一般不推荐使用这种方式，因为它只不过是一种补救错误的方法，而我们希望在编码者出错时能够立即提示错误。幸好，我们可以在编辑器中用插件与eslint搭配来满足实时提示错误的需求。</p><p>我自己喜欢使用<a href="https://atom.io/" target="_blank" rel="noopener">Atom</a>进行编码，以Atom为例，在Atom中安装<a href="https://atom.io/packages/linter" target="_blank" rel="noopener">linter</a>和<a href="https://atom.io/packages/linter-eslint" target="_blank" rel="noopener">linter-eslint</a>插件，eslint就会实时检查当前文件中的代码是否符合规范，on the fly!</p><h2 id="Git-hooks"><a href="#Git-hooks" class="headerlink" title="Git hooks"></a>Git hooks</h2><p>像其他的版本控制工具一样，git也提供了“钩子”功能——<a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks" target="_blank" rel="noopener">Git hooks</a>，用于在特定的重要动作发生时触发自定义脚本。git有客户端钩子和服务端钩子两种，客户端钩子用于提交、合并等场合，而服务端钩子则用于诸如接收push request、身份校验等场景。我们这里主要关注客户端钩子。</p><ul><li><code>pre-commit</code>钩子：在键入提交信息前运行,可以在提交前对代码风格进行校验,如果验证不通过，git将放弃刺激提交。当然，我们可以通过<code>git commit --no-verify</code>来跳过这个步骤</li><li><code>commit-msg</code>钩子：该钩子接收存有当前提交信息的临时文件作为参数，可用于检查项目状态或提交信息</li></ul><p>利用上述的两个钩子，就可以在执行commit的时候执行我们的自定义脚本。</p><p>推荐使用<a href="https://github.com/typicode/husky">husky</a>来管理hook脚本，该工具跨平台支持所有的git hooks，且可以很方便的管理自定义脚本。</p><h2 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h2><p>使用eslint检查代码很简单，直接使用<code>eslint</code>指令即可，如执行：</p><pre><code class="javascript">eslint --quiet index.js</code></pre><p>当然，该命令的参数也支持多文件名和文件夹，更是支持<code>*</code>匹配模式，因此我们可以在此基础上自定义自己的调用命令，这个稍后再介绍。</p><p>需要注意的是，在型项目中往往会有成百上千个文件，如果每次提交前都对所有的文件进行检查是效率很低的。因此，我们只对每次提交时修改过的文件进行检查，也就是只检查当前为<code>staged</code>状态的文件。</p><p><code>git diff HEAD --name-only</code>指令可以获得当前处于<code>staged</code>状态的所有文件的文件名(包含相对路径)，之后再调用<code>eslint</code>命令就能对实现commit前对代码文件袋呃检查，如果有某一个文件没有通过检查，则校验失败，当前<code>commit</code>也会被中止。</p><p><a href="https://github.com/okonet/lint-staged">lint-staged</a>可以帮助我们达到上述的目的，它的优点是非常友好，校验不通过的文件会高亮输出错误，一目了然。而且，该插件不仅支持js的检查，也支持css/scss的检查。只需要在package.json文件中配置好被检查的文件目录及对应的检查工具就可以了，如：</p><pre><code class="json">{    &quot;name&quot;: &quot;xxxx&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;A Vue.js project&quot;,    &quot;scripts&quot;: {        &quot;precommit&quot;: &quot;lint-staged&quot;    },    &quot;lint-staged&quot;: {        &quot;build/**/*&quot;: &quot;eslint&quot;,        &quot;config/**/*&quot;: &quot;eslint&quot;,        &quot;src/**/*.{js,vue}&quot;: &quot;eslint&quot;    }}</code></pre><p>配置好后，每次在执行<code>git commit</code>时，都会对lint-staged中所指定的目录下处于<code>staged</code>状态的文件执行eslint检查。</p><h2 id="代码格式化"><a href="#代码格式化" class="headerlink" title="代码格式化"></a>代码格式化</h2><p>现在，我们已经可以根据eslint rules对代码进行检查，但是仍需要手动定位错误所在的文件及其位置。毕竟码农都是”懒人”，那么能不能更进一步，“一键”修复错误呢？</p><p>调研发现，已有一个强大且成熟的工具——<a href="https://github.com/prettier/prettier">prettier</a>可以实现自动修复，但是美中不足的是它只能根据默认的规则（有少数自己自定义配置项）来格式化代码，而不支持自定义的eslint规则。</p><p>查阅eslint的官方文档，惊喜的发现eslint有一个<code>--fix</code>参数，在调用<code>eslint</code>命令执行检查时加上这个参数，就会自动地尽可能的修复检查错误。利用这个功能，就可以编写一个脚本来处理不同参数下如何自动修复错误的问题了。先上代码：</p><p>pretty.js</p><pre><code class="javascript">#!/usr/bin/env nodeconst child_process = require(&#39;child_process&#39;);const program = require(&#39;commander&#39;);const sgf = require(&quot;staged-git-files&quot;);const argv = process.argv;program  .version(&#39;0.1.0&#39;)  .usage(&#39;npm run pretty [-option] &lt;value&gt;&#39;)  .option(&#39;-s, --staged&#39;, &#39;Pretty staged js &amp; vue files&#39;)  .option(&#39;-a, --all&#39;, &#39;pretty all js &amp; vue files&#39;)  .option(&#39;-f, --files [files]&#39;, &#39;pretty file by name&#39;)  .option(&#39;-d, --directory [directory]&#39;, &#39;pretty files by directory&#39;)  .on(&#39;--help&#39;, () =&gt; {      console.log(&#39;  Examples:\n&#39;);      console.log(&#39;     npm run pretty -- -s&#39;);      console.log(&#39;     npm run pretty -- -a&#39;);      console.log(&#39;     npm run pretty -- -f src/index.js&#39;);      console.log(&#39;     npm run pretty -- -d packages/date-picker/src\n&#39;);  })  .parse(argv);if (argv.length === 2) {    // 未传入参数则输出帮助文档    program.help();}if(program.staged) {    // get staged files    // res = {    //     filename: &#39;xxxxx&#39;,    //     status: &#39;ADDED&#39;    // }    sgf((err, res) =&gt; {        if (err) {            console.error(err);            return;        }        let files = res.filter((item) =&gt; {            return item.filename.search(/.js$|.vue$/) !== -1;        }).map((file) =&gt; {            return file.filename;        });        fileStr = files.join(&#39; &#39;);        console.log(&#39;Prettying staged js &amp; vue files in the project:&#39;);        child_process.exec(`eslint --fix --quiet ${fileStr}`, (err, stdout, stderr) =&gt; {            console.log(stdout);            console.log(&#39;Pretty by eslint commpleted\n&#39;);        });    });}if (program.All) {    console.log(&#39;Prettying all js &amp; vue files in the project:&#39;);    child_process.exec(`eslint --fix --quiet --ext .js,.vue src`, (err, stdout, stderr) =&gt; {        console.log(stdout);        console.log(&#39;Pretty by eslint commpleted\n&#39;);    });}if(program.files) {    if (argv.length === 3) {        program.help();    }    console.log(&#39;Prettying file(s) by name:&#39;);    child_process.exec(`eslint --fix --quiet ${program.files}`, (err, stdout, stderr) =&gt; {        console.log(stdout);        console.log(&#39;Pretty by eslint commpleted\n&#39;);    });}if(program.directory) {    if (argv.length === 3) {        program.help();    }    console.log(&#39;Prettying file by directory:&#39;);    child_process.exec(`eslint --fix --quiet ${program.directory}/**/*.{js,vue}`, (err, stdout, stderr) =&gt; {        console.log(stdout);        console.log(&#39;Pretty by eslint commpleted\n&#39;);    });}</code></pre><p>这里使用了<a href="https://github.com/tj/commander">commander</a>，以便从命令行接收参数并自动生成帮助文档。上述代码定义了4个参数：<code>staged</code>、<code>all</code>、<code>files</code>和<code>directory</code>，分别用于格式化<code>处于staged状态的文件</code>、<code>项目中所有的文件</code>、<code>参数指定的文件</code>以及<code>指定目录内的文件</code>，这里只对项目中的js和vue文件做检查。<br>这里使用了node的<a href="https://nodejs.org/api/child_process.html" target="_blank" rel="noopener"><code>child_process</code>特性</a>，在脚本内新建一个子进程去处理格式化任务。</p><p>调用脚本时，如果未正确传入参数，则用<code>program.help()</code>输出帮助文档。<br>可以在package.json中配置一个<code>pretty</code>命令来执行脚本，如：</p><pre><code class="json">{    &quot;scripts&quot;: {        &quot;pretty&quot;: &quot;node pretty.js&quot;    }}</code></pre><p>有了如上的配置，就可以在命令行中用<code>npm run pretty</code>命令来调用脚本了。根据传入的不同参数和参数值，调用<code>eslint --fix</code>执行不同的格式化任务，达到”一键美颜“的目标！</p><p><strong>注意</strong>： npm run 后面的参数只能传给run后面跟的脚本本身，如这里如果执行<code>npm run pretty -a</code>，参数<code>a</code>只能传递给<code>pretty</code>，等效于执行<code>node pretty.js -a</code>，<br>这样在pretty.js内部就拿不到参数<code>a</code>。在<code>npm run</code>命令的参数前加上<code>--</code>，也即：<code>npm run pretty -- -a</code>，就可以将命令行的参数传入实际被执行的脚本（pretty.js）了。</p><h2 id="commit信息校验"><a href="#commit信息校验" class="headerlink" title="commit信息校验"></a>commit信息校验</h2><p>规范化的commit信息可以：</p><ul><li>方便浏览定位日志记录</li><li>自动生成changelog</li></ul><p>如上文所述，我们可以在<code>commit-msg</code>钩子中来校验commit消息，如检查输入的commit信息是否符合预定义的格式，字符是不是超过预定长度等。</p><h3 id="git-commit-格式规范"><a href="#git-commit-格式规范" class="headerlink" title="git commit 格式规范"></a>git commit 格式规范</h3><pre><code class="javascript">git commit -m &#39;&lt;type&gt;(scope): &lt;detail&gt;&#39;</code></pre><p>示例：</p><pre><code class="javascript">git commit -m &#39;feature(ivr): change color of svg node&#39;</code></pre><ol><li><p><code>type</code>：<font color="red">本次commit的类别</font></p><ul><li>feature：新功能</li><li>fix：修补bug</li><li>doc：文档</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul></li><li><p><code>scope</code>：<font color="red">本次commit所属的需求名或影响范围</font></p></li><li><p><code>detail</code>：<font color="red">本次commit的简短描述</font></p><ul><li>不超过100个字符</li><li>以动词开头，使用现在时，如change、fix、remove等</li><li>首字母小写</li><li>结尾不加句号（.）</li></ul></li></ol><p>这里我们使用<a href="https://github.com/conventional-changelog/validate-commit-msg">validate-commit-msg</a>来配置上述的git commit规范。在项目根目录添加<code>.vcmrc</code>文件：</p><pre><code class="json">{  &quot;types&quot;: [&quot;feature&quot;, &quot;fix&quot;, &quot;doc&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;test&quot;, &quot;chore&quot;, &quot;revert&quot;],  &quot;scope&quot;: {    &quot;required&quot;: true,    &quot;allowed&quot;: [&quot;*&quot;],    &quot;validate&quot;: false,    &quot;multiple&quot;: false  },  &quot;warnOnFail&quot;: false,  &quot;maxSubjectLength&quot;: 100,  &quot;subjectPattern&quot;: &quot;.+&quot;,  &quot;subjectPatternErrorMsg&quot;: &quot;subject does not match subject pattern!&quot;,  &quot;helpMessage&quot;: &quot;\ngit commit规范：\n\nExample：\nfeature(ivr): change color of svg node\n\ntype -- 本次commit的类别，可选值：\n - feature：新功能\n - fix：修补bug\n - doc：文档\n - style： 格式(不影响代码运行的变动)\n - refactor：重构(即不是新增功能，也不是修改bug的代码变动)\n - test：增加测试 \n - chore：构建过程或辅助工具的变动\n\nscope -- 本次commit所属的需求名或影响范围\n\ndetail -- 本次commit的简短描述\n - 不超过50个字符\n - 以动词开头,使用现在时，如change、remove等\n - 首字母小写\n - 结尾不加句号(.)&quot;,  &quot;autoFix&quot;: true}</code></pre><p>如此一来，提交commit的时候都会根据上述模板对commit信息进行校验，如不符合规范则无法提交commit，并提示错误信息。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>简单地利用ESlint和Git，我们就可以完成代码检查、代码自动修复、commit信息校验的工作，团队合作的效率就像一把梭，on the fly！</p>]]></content>
      
      
      <categories>
          
          <category> Development </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>填坑行动之纯静态页面中使用Vue</title>
      <link href="/2017/07/26/vue-in-staticPage/"/>
      <url>/2017/07/26/vue-in-staticPage/</url>
      
        <content type="html"><![CDATA[<blockquote><p>现在团队除了一些老项目，基本上已经完全切换到了Vue，我们也开发了自己的基础组件库<code>VHTML</code>。不过最近接手的一个项目是纯静态的，没有使用任何的构建或打包工具。但是设计师大大给出的设计稿沿用了基础组件库的设计风格，如果要用jQuery来实现，工作量将会很大，因此考虑在页面中引入Vue并使用VHTML的基础组件，从而大大缩短开发量。本以为像使用jQuery一样，简单的引入Vue之后使用就可以了，事实证明我还是too young too naive。就用这篇文章来纪念一下开发过程中踩过的各个坑。</p></blockquote><a id="more"></a><h2 id="1号坑"><a href="#1号坑" class="headerlink" title="1号坑"></a>1号坑</h2><p>第一件事情当然是引入Vue，由于我们没有webpack这样的编译工具，需要实时编译模板，因此不能使用<code>runtime</code>版本的Vue(vue.runtime.js)，而必须使用包含编译器的完整版Vue(vue.js)。</p><p>之前在<code>.vue</code>文件中写vue代码时，我们是将整个vue文件当做一个组件来看的，而在js文件中写Vue部分的代码跟写<code>.vue</code>文件有点不一样，我们需要手动new一个全局的vue实例，如下：</p><pre><code class="javascript">var vueInstance = new Vue({    el: &#39;#app&#39;,    data: function() {},    methods: {}});</code></pre><p>需要注意的是，由于<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">IE浏览器基本上不支持ES6</a>，而我们使用的vue没有进行预编译，因此我们不能像往常一下在vue中使用ES6的特性，如：函数简写、<code>let</code>、<code>const</code>等，只能老老实实的用一般语法来写。</p><pre><code class="javascript">data: fucntion () {}</code></pre><p>简写为：</p><pre><code class="javascript">data() {}</code></pre><p>类似这样额缩写写法偶尔会报错，但是不是百分之百复现，可能跟浏览器兼容性设置有关，所以为了兼容IE9，最好不要采用简写的写法。</p><h2 id="2号坑"><a href="#2号坑" class="headerlink" title="2号坑"></a>2号坑</h2><p>好了，成功在页面中引入了Vue和VHTML，官方说Vue支持IE9+，随即在IE9上测试一下，页面并没有像预期中的完美呈现。</p><p>打开IE9的调试面板，发现IE9是将我们的页面按照IE7兼容模式来渲染的，自然不支持Vue。于是检查页面<code>&lt;head&gt;</code>中的兼容性配置，此时的配置如下：</p><pre><code class="html">&lt;head&gt;    &lt;script&gt;        var GSTS = new Date();    &lt;/script&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1,user-scalable=no&quot;&gt;&lt;/head&gt;</code></pre><p>咦，没有问题呀，<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>告诉IE浏览器以它支持的最高级的模式呈现页面，但是为什么这里没有生效，而是以IE7的模式渲染的呢？</p><p>为了解决这个问题，将<a href="https://stackoverflow.com/questions/6771258/what-does-meta-http-equiv-x-ua-compatible-content-ie-edge-do" target="_blank" rel="noopener">页面兼容性设置的相关知识</a>都研究了一遍。但是查阅无数资料、试了好几台机器的IE9，都没有找到问题所在。</p><p>一个偶然，在查看页面源代码的时候发现：在IE9下以IE标准模式正常呈现的页面的<code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>标签都是作为<code>&lt;head&gt;</code>的第一个标签，而在我的页面中，<code>&lt;head&gt;</code>内的第一个标签是一个<code>script</code>标签：</p><pre><code class="javascript">&lt;script&gt;    var GSTS = new Date();&lt;/script&gt;</code></pre><p>果断把这个标签去掉试一试，果然！页面成功已IE9标准模式渲染出来了！</p><p>再仔细检查，发现这个项目中所有的页面的<code>&lt;head&gt;</code>起始处都添加了这么一段代码，是之前一个同事部署监测代码的时候添加的。果然，其他加了这段代码的页面在IE9下也无法正常呈现。</p><p>查阅MDN文档之后发现：<font color="red"><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>必须是<code>&lt;head&gt;</code>的第一个标签才能生效！</font></p><h2 id="3号坑"><a href="#3号坑" class="headerlink" title="3号坑"></a>3号坑</h2><p>开发过程中遇到的最棘手的也是费时的坑是CORS跨域问题。</p><p>由于当前项目之前是纯静态页面，所以没有专门的PHP服务，因此ajax请求需要走另一套系统的PHP服务，这就需要进行ajax跨域请求了。</p><p>这里的使用场景是前端提交查询跨域请求之后由php返回查询结果，因此用jsonp的方式不是很适合，于是想到了用CORS,但是需要后端的配合。行，方案定了之后，一个字就是：干！</p><p>CORS跨域请求的具体实施方案，可参考MDN的参考文档<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#" target="_blank" rel="noopener">HTTP访问控制（CORS）</a>。</p><p>简单的来说，首先在Nginx服务器上需要做如下配置：</p><pre><code class="php">## Wide-open CORS config for nginx#location / {     if ($request_method = &#39;OPTIONS&#39;) {        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;        #        # Custom headers and headers various browsers *should* be OK with but aren&#39;t        #        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&#39;;        #        # Tell client that this pre-flight info is valid for 20 days        #        add_header &#39;Access-Control-Max-Age&#39; 1728000;        add_header &#39;Content-Type&#39; &#39;text/plain; charset=utf-8&#39;;        add_header &#39;Content-Length&#39; 0;        return 204;     }     if ($request_method = &#39;POST&#39;) {        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&#39;;        add_header &#39;Access-Control-Expose-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&#39;;     }     if ($request_method = &#39;GET&#39;) {        add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;;        add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;;        add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&#39;;        add_header &#39;Access-Control-Expose-Headers&#39; &#39;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Content-Range,Range&#39;;     }}</code></pre><p>然后，PHP在返回的响应头上加上：<code>&#39;Access-Control-Allow-Origin&#39; &#39;*&#39;</code>，最后前端在使用jQuery发送ajax请求时，需要配置<code>crossDomain</code>参数为<code>true</code>。</p><p>按上面的方案配置好后，基本上就可以解决跨域问题了。但是在测试环境中，由于公司代理的影响，会导致跨域的时候不断的发生302重定向，猜测可能是公司代理服务器不允许跨域请求。</p><p>在兼容性方面，这个方案支持主流的浏览器，包括IE8+。</p><p>做完这个需求，虽然感觉自己脱了一层皮，加了几天的班就为了解决一些从没遇到过的奇奇怪怪的问题，但经历风雨方能见到彩虹。</p><p>一通折腾下来，最大的感受是：脱离现有开发框架，收获的东西远比在既定框架里开发来得多。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>highcharts-pattern-fill</title>
      <link href="/2017/05/14/highcharts-pattern-fill/"/>
      <url>/2017/05/14/highcharts-pattern-fill/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.highcharts.com/" target="_blank" rel="noopener">Highcharts</a>是一个优秀的数据可视化图表库，它具有很高的自定义度，只需要通过JSON对象进行配置即可。在最近的一个需求中要求区域图的填充必须为斜线，调研了一番之后发现Highcharts本身并不支持斜线填充，所幸highcharts提供了一个可以实现此功能的插件<a href="https://github.com/highcharts/pattern-fill">pattern-fill</a>。本文简要分析pattern-fill的实现原理及使用方法。</p></blockquote><a id="more"></a><h2 id="pattern-fill简介"><a href="#pattern-fill简介" class="headerlink" title="pattern-fill简介"></a>pattern-fill简介</h2><p>pattern-fill作为Highcharts的插件存在。顾名思义，这个插件使得我们可以在任意区域内用图案进行填充。pattern-fill目前更新到2.X版本，其中1.X版本兼容Highcharts 3，而2.X版本与Hicharts 4+ 兼容。两个版本的主要区别是：1.X 只支持使用图像进行填充，而2.X版本除了支持图像填充、更改了部分API之外，最重要的新特性是支持SVG填充，这大大增强了其适用性。</p><p>本文主要介绍2.X版本的pattern-fill。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>pattern-fill的源码只有180多行，我们来看一下它都干了些什么。</p><p>它做的第一件事是在 <strong>Highcharts的SVGRenderer对象的原型对象上添加一个addPattern方法</strong>，该方法的作用是在渲染器上定义并添加pattern：</p><pre><code class="js">Highcharts.SVGRenderer.prototype.addPattern = function (id, options) {        // 仅看核心代码        // Step1：创建一个pattern并将其添加到defs中        pattern = this.createElement(&#39;pattern&#39;).attr({            id: id,            patternUnits: &#39;userSpaceOnUse&#39;, // 表示坐标系统由pattern被引用时所在的坐标系统确定            width: options.width || 10,            height: options.height || 10           }).add(this.defs);        // Step2: 给pattern添加图像填充        if (options.path) {        path = options.path;        // 设置path的背景色        if (path.fill) {            rect(path.fill);        }        // 绘制pattern        this.createElement(&#39;path&#39;).attr({            d: path.d || path,            stroke: path.stroke || options.color || &#39;#343434&#39;,            &#39;stroke-width&#39;: path.strokeWidth || 2        }).add(pattern);        pattern.color = options.color;    // 第二种模式：用图片来定义pattern    }    else if (options.image) {        this.image(options.image, 0, 0, options.width, options.height).add(pattern);    }};</code></pre><p><code>addPattern</code> 函数第一步是创建一个pattern并将其添加到defs中， defs是SVG规范规定的用于存放待使用的图形对象的容器，Highcharts也对这个特性提供了支持，因此，这里将定义的pattern对象都添加到defs对象中。<br>这里支持了SVG的path和图像两种方式来定义pattern，通过传入不同的options来使用不同的定义方式：使用svg时配置path属性，而image则配置image属性。</p><p>定义好了pattern之后，还需要让Highcharts的渲染引擎支持两种方式的渲染。pattern-fill是通过重写Highcharts元素的<code>fillSetter</code>函数来实现的：</p><pre><code class="js">    // proceed是被重写的函数本身，作为第一个参数传入回调    Highcharts.wrap(Highcharts.VMLRenderer.prototype.Element.prototype,    &#39;fillSetter&#39;, function (proceed, color, prop, elem) {        if (typeof color === &#39;string&#39; &amp;&amp; color.substring(0, 5) === &#39;url(#&#39;) {            var id = color.substring(5, color.length - 1),                pattern = this.renderer.patterns[id],                markup;            if (pattern.image) {                // Remove Previous fills                if (elem.getElementsByTagName(&#39;fill&#39;).length) {                    elem.removeChild(elem.getElementsByTagName(&#39;fill&#39;)[0]);                }                markup = this.renderer.prepVML([&#39;&lt;&#39;, prop, &#39; type=&quot;tile&quot; src=&quot;&#39;, pattern.image, &#39;&quot; /&gt;&#39;]);                elem.appendChild(document.createElement(markup));                // Work around display bug on updating attached nodes                if (elem.parentNode.nodeType === 1) {                    elem.outerHTML = elem.outerHTML;                }            } else if (pattern.color) {                proceed.call(this, pattern.color, prop, elem);            } else {                proceed.call(this, &#39;#A0A0A0&#39;, prop, elem);            }        } else {            proceed.call(this, color, prop, elem);        }    });</code></pre><p>Highcharts不仅本身具有丰富的API可供使用，而且还提供了一些工具方法用于扩展，详细请参考<a href="https://www.highcharts.com/docs/extending-highcharts/extending-highcharts" target="_blank" rel="noopener">Extending Highcharts</a>。<code>wrap</code>函数就是Highcharts提供的用于扩展已有原型对象方法的工具函数，这里使用它重写了Element原型对象上的<code>fillSetter</code>函数，使得Highcharts在渲染元素的颜色时支持以<code>url(#pattern-id)</code>的方式识别svg path和image。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>分析完pattern的源码，其用法就很明了了：先在defs中定义自己的pattern（svg或图片），然后在chart的配置项中用<code>color: url(#pattern-id)</code>的形式使用该pattern。<br>看一个实例：</p><pre><code class="js">options: {    // defs中自定义pattern    defs: {        patterns: [{            // SVG pattern            id: &#39;light-green-pattern&#39;,            path: {                d: &#39;M 0 5 L 5 0 M -1 1 L 1 -1 M 4 6 L 6 4&#39;,                stroke: &#39;#00cc26&#39;, // 线条颜色                strokeWidth: 1,                fill: &#39;#CCF5D4&#39;    // path的背景颜色            },            width: 5,            height: 5        }, {        // image pattern        id: &#39;image-pattern&#39;,        image: &#39;src/images/loading.png&#39;        }]    }},series: [{    name: &#39;浏览量&#39;,}, {    name: &#39;访客数&#39;,    // 在配置项series中根据id使用自定义pattern    fillColor: &#39;url(#light-green-pattern)&#39;,    color: &#39;url(#light-green-pattern)&#39;,    lineWidth: 0,    marker: {        fillColor: &#39;#00cc26&#39;    }}]</code></pre><p>下面是使用自定义斜线填充的效果图，完美符合设计师大大的要求。</p><p><img src="/assets/img/splash-chart.png" width="1000"></p><p>终于可以开心地使用Highcharts了！</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue之自定义指令</title>
      <link href="/2017/05/07/vue-directives/"/>
      <url>/2017/05/07/vue-directives/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道在Vue中，代码复用和抽象的主要形式是<strong>组件</strong>。但是在有些情况下，我们可能仅需要操作一些普通元素，这个时候如果也使用自定义组件会显得很笨重。因此，Vue允许注册自定义指令来实现一些简单的功能。本文将结合自定义指令<code>on-scrollto</code>来看看在Vue中是如何实现自定义指令的。</p></blockquote><a id="more"></a><h2 id="注册指令"><a href="#注册指令" class="headerlink" title="注册指令"></a>注册指令</h2><p>首先，我们需要在Vue上注册我们的指令。Vue提供了两种方式来注册指令，第一种是全局注册的方式：</p><pre><code class="js">// 定义一个全局的自定义指令：v-on-scrolltoVue.directive(&#39;name&#39;, {    // 定义该指令的一系列钩子函数，这些钩子函数都是可选的    bind() {},  // 仅在指令第一次绑定到元素上时被调用，用于做初始化    inserted() {},  // 绑定的元素被插入到父节点时被调用    update() {},    // 使用该指令的组件有更新时被调用，可能早于其子组件的更新    componentUpdated() {},  // 组件及其子元素都更新完之后才会被调用    unbind() {} // 指令从元素上解绑时被调用})</code></pre><p>另一种是局部注册的方式，组件可以接受一个<code>directives</code>配置项，这种方式定义的指令只能作用于当前组件：</p><pre><code class="js">directives: {    name: {        // directive definition    }}</code></pre><h2 id="钩子函数的参数"><a href="#钩子函数的参数" class="headerlink" title="钩子函数的参数"></a>钩子函数的参数</h2><p>上面用于定义指令的钩子函数都会被传入下列参数，我们通过在钩子函数中使用这些参数来实现指令的功能：</p><ul><li><code>el</code>: 绑定指令的元素，可以直接用来操作DOM</li><li><code>binding</code>: 一个包含下列属性的对象<ul><li><code>name</code>: 指令的名字，不包括<code>v-</code>前缀</li><li><code>value</code>: 指令接收的值，如<code>v-on-scrollto=&quot;v-my-directive=&quot;1 + 1&quot;</code>对应的value值为2</li><li><code>oldValue</code>: 指令的上一个值，只在update和componentUpdated函数中可用</li><li><code>expression</code>: 绑定指令的表示字符串，如上面的<code>&quot;1 + 1&quot;</code></li><li><code>arg</code>: 传入指令的参数，如果有的话。如<code>v-my-directive:foo</code>中的参数为<code>foo</code></li><li><code>modifiers</code>: 如果有修饰符的话，该参数为包含修饰符的对象，如<code>v-my-directive.foo.bar</code>，modifiers的值为：<code>{foo: true, bar: true}</code></li></ul></li><li><code>vnode</code>: Vue编译器生成的虚拟节点</li><li><code>oldVnode</code>: 上一个虚拟节点，只在update和componentUpdated中可用</li></ul><h2 id="on-scrollto指令的实现"><a href="#on-scrollto指令的实现" class="headerlink" title="on-scrollto指令的实现"></a><code>on-scrollto</code>指令的实现</h2><p>接下来我们结合代码看看<code>on-scrollto</code>指令是怎么定义的。顾名思义，这个指令实现的功能是：绑定元素滚动到某个位置时，执行某些操作。我们直接来看代码。</p><p>这里为了与Vhtml的组件定义形式保持一致，将指令的定义拆分为两个文件：index.js 和 on-scrollto-directive.js文件，index.js文件作为指令的入口，而on-scrollto-directive.js文件则保存了指令的具体定义。<br>index.js中的代码：</p><pre><code class="js">// 引入定义指令的文件import OnScrollto from &#39;./src/on-scrollto-directive&#39;;// 定义OnScrollto的install函数，该函数内部是声明on-scrollto指令的语句/* istanbul ignore next */OnScrollto.install = function (Vue) {    Vue.directive(OnScrollto.name, OnScrollto);};export default OnScrollto;</code></pre><p>on-scrollto-directive.js中的代码：</p><pre><code class="js">import {on, off, getComputedStyle} from &#39;vhtml-ui/src/utils/dom&#39;;import debounce from &#39;vhtml-ui/src/utils/debounce&#39;;const POSITION_MAP = {    bottom: function (el, currentTop) {        const styles = getComputedStyle(el);        const borderTop = parseInt(styles.borderTopWidth, 10);        const borderBottom = parseInt(styles.borderBottomWidth, 10);        const targetTop = el.scrollHeight - (el.offsetHeight - borderTop - borderBottom);        return (currentTop &gt; 0) &amp;&amp; (currentTop &gt;= targetTop);    },    top: function (el, currentTop) {        return currentTop &lt;= 0;    }};const calcPostion = debounce(function (el, binding) {    if (typeof binding.value !== &#39;function&#39;) {        return;    }    Object.keys(binding.modifiers).forEach((mod, index) =&gt; {        if (!POSITION_MAP[mod]) {            return;        }        const currentTop = el.scrollTop;        const result = POSITION_MAP[mod](el, currentTop);        if (result) {            binding.value(mod, currentTop);        }    });}, 200);const HOOK_PROPNAME = &#39;VHTML_ON_SCROLLTO_DIRECTIVE&#39;;export default {    name: &#39;on-scrollto&#39;,    bind(el, binding, vnode) {        const onscroll = function () {            calcPostion(el, binding);        };        on(el, &#39;scroll&#39;, onscroll);        Object.defineProperty(el, HOOK_PROPNAME, {            value: onscroll,            enumerable: false        });    },    unbind(el) {        const onscroll = el[HOOK_PROPNAME];        off(el, &#39;scroll&#39;, onscroll);    }};</code></pre><h3 id="指令定义解析"><a href="#指令定义解析" class="headerlink" title="指令定义解析"></a>指令定义解析</h3><p>我们分步骤来看定义指令的代码，首先看定义的主体，即下面几行代码：</p><pre><code class="js">HOOK_PROPNAME = &#39;VHTML_ON_SCROLLTO_DIRECTIVE&#39;;export default {    name: &#39;on-scrollto&#39;,    bind(el, binding, vnode) {        const onscroll = function () {            calcPostion(el, binding);        };        on(el, &#39;scroll&#39;, onscroll);        Object.defineProperty(el, HOOK_PROPNAME, {            value: onscroll,            enumerable: false        });    },    unbind(el) {        const onscroll = el[HOOK_PROPNAME];        off(el, &#39;scroll&#39;, onscroll);    }};</code></pre><p>在钩子函数<code>bind</code>中使用了el、binding、vnode三个参数。首先，声明了一个onscroll函数，该函数里会执行我们定义的calcPostion函数，我们稍后再分析这个函数的代码。随后将onscroll函数绑定为元素原生<code>scroll</code>事件的回调函数，每当元素的scroll事件被触发时，就会执行calcPostion函数。然后，在元素上定义了一个不可枚举的属性<code>VHTML_ON_SCROLLTO_DIRECTIVE</code>，它的值为<code>onscroll</code>。我们通过这个属性来标记元素是否绑定了<code>onscroll</code>回调函数。<br>钩子函数<code>unbind</code>很简单，只是解除了<code>onscroll</code>函数的绑定。</p><p>POSITION_MAP定义了两个触发条件（两个位置计算函数）：bottom和top，它们都返回Boolean类型的值，内部的逻辑分别是满足滑动到元素底部的条件和滑动到元素顶部的条件。某个函数返回值为真时，表示对应的条件成立（滚动条滑到了底部或顶部）。</p><pre><code class="js">const POSITION_MAP = {    bottom: function (el, currentTop) {        const styles = getComputedStyle(el);        const borderTop = parseInt(styles.borderTopWidth, 10);        const borderBottom = parseInt(styles.borderBottomWidth, 10);        const targetTop = el.scrollHeight - (el.offsetHeight - borderTop - borderBottom);        return (currentTop &gt; 0) &amp;&amp; (currentTop &gt;= targetTop);    },    top: function (el, currentTop) {        return currentTop &lt;= 0;    }};</code></pre><p>再看<code>calcPostion</code>函数：</p><pre><code class="js">const calcPostion = debounce(function (el, binding) {    if (typeof binding.value !== &#39;function&#39;) {        return;    }    Object.keys(binding.modifiers).forEach((mod, index) =&gt; {        if (!POSITION_MAP[mod]) {            return;        }        const currentTop = el.scrollTop;        const result = POSITION_MAP[mod](el, currentTop);        if (result) {            binding.value(mod, currentTop);        }    });}, 200);</code></pre><p>因为我们无法知道DOM元素的原生事件的触发周期，因此这里calcPostion函数的定义使用了防抖动函数debounce，使得calcPostion函数在200ms内只被执行一次。</p><p>然后会遍历指令绑定的修饰符，如果指令的当前修饰符绑定的值不是函数，则直接返回；如果绑定的值是函数，且滚动条的位置满足触发条件（bottom或top)，则执行指令绑定的回调函数（即指令的绑定值）。</p><p>就这样，简单的<code>on-scrollto</code>指令就定义好了，它具有两种修饰符可选：bottom、top，滑动滚动条满足相应的条件就会将指令绑定的值（函数）作为回调函数执行。</p><h2 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h2><p>在元素上绑定指令的格式很简单，如下：</p><pre><code class="html">&lt;element v-on-scrollto.bottom=&quot;handleToBottom&quot;&gt;&lt;/element&gt;&lt;element v-on-scrollto.top=&quot;handleToTop&quot;&gt;&lt;/element&gt;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过一个简单的滚动条指令来说明了Vue中自定义指令的定义规范，麻雀虽小五脏俱全。通过本例的扩展即可编写更加复杂而实用的自定义指令。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闭包那点事儿</title>
      <link href="/2017/03/15/js-closure/"/>
      <url>/2017/03/15/js-closure/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直以来都没有彻底理解JavaScript的闭包特性及其使用，《JavaScript Ninja》中 <strong>闭包</strong> 一章是我读过讲解闭包的书籍或博客中，梳理的最清晰的，以此为基础整理了自己对闭包的理解。</p></blockquote><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ol><li>闭包是什么，如何工作？ - 闭包的几个重要概念</li><li>闭包的使用<ul><li>私有变量</li><li>函数回调</li><li>绑定函数上下文</li><li>偏应用函数</li><li>函数重载</li><li>立即执行函数</li></ul></li></ol><a id="more"></a><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p>简单的说，闭包(closure)是一个函数在创建时允许让自身函数访问并操作该自身函数所在作用域内的变量时所创建的作用域。</p><p>我们来分析闭包的这个定义。闭包代表的是一个函数的作用域，那么这个作用域有什么特点呢？首先，这个作用域在函数创建的时候就存在了；其次，这个作用域可以让创建的这个函数可以访问该函数之外（函数被创建时所在的作用域内）的变量。正常情况下，函数执行完之后，它的作用域也就消失了，作用域内的变量也会随之消失。但是如果存在闭包，即使该作用域消失了，其内部的某些变量和函数仍能被访问到。这就是闭包的作用。</p><p>我们来看一个简单的闭包：</p><pre><code class="js">var outer = &#39;outerman&#39;;var later;function outerFunction() {    var inner = &#39;innerman&#39;;    function innerFunction() {        console.log(outer);        console.log(inner);    }    later = innerFunction;}outerFunction();later();    // outerman            // innerman</code></pre><p>执行上面的代码后，肯定会输出“outerman”，因为outer变量是在全局作用域的，在任何作用域内都可见。那么inner变量是输出‘innerman’还是undefined呢？</p><p>答案是输出“innerman”。执行外部函数<code>outerFunction</code>之后，我们通过引用变量later来调用内部函数，内部函数执行时，外部函数内的作用域（inner变量所在的作用域）已经不复存在。那么我们的内部函数又怎么能够访问到该变量呢？这就是闭包的魔力！</p><p>外部函数中声明innerFunction的时候，不仅声明了函数，还为该函数创建了一个闭包，该闭包不仅包含函数声明，还包含了函数声明的那一刻该作用域中的所有变量。因此，虽然外部函数的作用域消失了，仍可以通过闭包访问到原始作用域中的inner变量。</p><p>如下图所示，闭包就像一个“安全气泡”，包含了声明函数那一刻的作用域内的所有函数和变量，为该函数的执行提供了所需的所有条件。</p><p><img src="/assets/img/closure.png" alt="闭包"></p><p>接下来我们看一个复杂一点的闭包，了解下闭包的一些核心原则。</p><pre><code class="js">var outer = &#39;outerman&#39;;var later;function outerFunction() {    var inner = &#39;innerman&#39;;    function innerFunction(param) {        console.log(outer);        console.log(inner);        console.log(param);        console.log(tooLate);    }    later = innerFunction;};console.log(tooLate); // undefinedvar tooLate = &#39;comming&#39;; outerFunction();later(&#39;pass&#39;);      // outerman                    // innerman                    // post                    // comming</code></pre><p>执行上面的代码后，四个变量均会输出相应的值，即使是在内部函数声明之后声明的变量tooLate也能在内部函数被访问到。</p><p>这个结果可以总结出闭包的三个核心原则：</p><ul><li>内部函数的参数是包含在闭包中的。</li><li>作用域之外的所有比阿娘，即便是函数声明之后的那些声明，也都包含在闭包中。</li><li>相同的（闭包）作用域内，尚未声明的变量不能进行提前引用。</li></ul><p>理解了闭包的核心原则，我们基本上就明白了闭包是个什么东东。另外一点需要注意的是，闭包的使用是有代价的：闭包里的信息会一直保存在内存里，直到JS引擎确认这些信息不会再被使用之后才会被回收。</p><p>接下来，我们总结下在实际开发过程中使用闭包的常见情况。</p><h2 id="闭包的使用"><a href="#闭包的使用" class="headerlink" title="闭包的使用"></a>闭包的使用</h2><h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><p>将某些变量封装为“私有变量”是一种使用闭包的常见方法。通常的做法是在构造器内隐藏变量，使其在外部作用域不可访问，但是可以存在于内部方法的闭包内。<br>如下面的例子：</p><pre><code class="js">function Ninja () {    var feints = 0;    this.getFeints = function () {        return feints;    };    this.feint = function () {        feints++;    }    var ninja = new Ninja();    ninja.feint();    console.log(ninja.getFeints()); // 1    console.log(ninja.feints);  // undefined}</code></pre><p>上面的代码中，构造器内部的变量feints只能在构造器内被访问，要从外部访问到该变量，我们可以通过getFeints()对其进行访问，通过feint()方法对其进行修改。<br>从输出结果可以看出，feints变量是ninja的“私有变量”，其作用域只在内部可见。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>在使用回调时，回调函数都是在后期未指定的时间进行异步调用，而在回调函数内部经常需要访问外部数据。闭包正是这种数据访问方式的直观体现，因为它可以使我们不用创建全局变量来保存这些外部数据。<br>见下面的例子：</p><pre><code class="js">function animateIt(elementId) {    var elem = document.getElementById(elementId);    var tick = 0;    var timer = setInterval(function(){                                 if (tick &lt; 100) {            elem.style.left = elem.style.top = tick + &#39;px&#39;;            tick++;        }        else {            clearInterval(timer);            // 这三个变量都可以在回调用被访问到            console.log(tick);  // 100            console.log(elem);            console.log(timer);        }    }, 10);}animateIt(&#39;box&#39;);</code></pre><p>通过在函数内部定义变量，并依赖闭包，可以使得这些变量在计时器回调函数中被访问到，每次执行animateIt()函数时都会有其私有的闭包，这样就可以不会污染全局作用域。<br>需要注意的是，闭包不是在创建那一时刻的状态的快照，而是一个真实的状态封装，只要闭包存在，其内部的变量就能够被更新。</p><h3 id="绑定函数上下文"><a href="#绑定函数上下文" class="headerlink" title="绑定函数上下文"></a>绑定函数上下文</h3><p>大家可能有听过或使用过bind()函数，bind函数的作用是将某个函数绑定到特定的对象上，并返回一个匿名函数，从而强制将函数的上下文设置为我们想要的任何对象。<br>我们来看下Prototype库中实现bind函数的示例：</p><pre><code class="js">Function.prototype.bind = function () {    var fn = this,    var args = Array.prototype.slice.call(arguments);    var object = args.shift();    return function () {        return fn.apply(object, args.concat(Array.prototype.slice.call(arguments)));    };};</code></pre>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript创建对象的几种方式</title>
      <link href="/2017/02/09/js-create-object/"/>
      <url>/2017/02/09/js-create-object/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript作为一门动态性的面向对象的编程语言，其核心思想就是一切皆对象。为了深入理解JS面向对象的编程思想，本文总结了几种常见的创建JS对象的方法，比较了各自的优缺点以及使用场景。</p></blockquote><blockquote><p>参考书籍：《Javascript高级程序设计》（第3版）、《Javascript权威指南》 </p></blockquote><a id="more"></a><h4 id="1-对象字面量"><a href="#1-对象字面量" class="headerlink" title="1. 对象字面量"></a>1. 对象字面量</h4><p>这是创建对象最简单的方式，对象是由若干“名/值”对组成的映射表：</p><pre><code class="javascript">var obj = {&quot;name&quot;: &quot;obj&quot;; &quot;age&quot;: 24};</code></pre><h4 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h4><p>工厂模式是软件工程领域一种广为人知的设计模式，用函数来封装并以特定接口创建对象的细节，实现方式如下：</p><pre><code class="javascript">// 在函数内创建对象，给新创建的对象添加属性和方法，并显式得返回。function createObj(name){    var obj = new Object();    obj.name = name;    obj.getName = function(){        return this.name;    };    return obj;}var person = createObj(&quot;Test&quot;);person.getName(); //Test</code></pre><p>函数createObj()能够根据接受的参数来创建一个person对象；可见，工厂模式可以创建多个相似对象，但是我们不能确定通过工厂模式创建的对象的类型。</p><h4 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3. 构造函数模式"></a>3. 构造函数模式</h4><p>构造函数可以创建特定类型（Array、Object）的对象，也可以创建自定义的对象，并为对象定义自定义的属性和方法：</p><pre><code class="javascript">//使用原生的构造函数var arr = new Array();   //创建一个数组对象var myDate = new Date();    //创建一个date对象function Person(name, age){    this.name = name;    this.age = age;    this.sayName = function(){        return this.name;    };}var person1 = new Person(&quot;Xiao&quot;, 24);  //用自定义的构造函数创建一个对象</code></pre><p>需要注意的是，自定义的构造函数名一般以大写字母开头。<br>使用构造函数创建对象必须使用new操作符，这里new操作符主要做了这几件事：</p><blockquote><ol><li>创建一个新对象；</li><li>把构造函数的this指向新对象；</li><li>为新对象添加属性和方法；</li><li>返回这个新对象。</li></ol></blockquote><p>构造函数模式可以创建特定类型的对象实例，但是它的主要缺点是构造函数中的方法要在每个实例上重新创建一遍，但是方法都是Function的实例，所以构造函数的不同实例的同名函数其实是不相等的。</p><h4 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h4><p>我们创建每一个函数都有一个prototype属性，它指向一个对象，该对象包含有特定类型的所有实例共享的属性和方法。也就是说prototype就是通过构造函数创建的对象实例的原型对象。因此，我们可以在原型对象上定义属性和方法，而不必在构造函数中定义：</p><pre><code class="javascript">function Person(){}；Person.prototype.name = &quot;Hanks&quot;;Person.prototype = 24;Person.prototype.sayName = function(){    return this.name;};var person1 = new Person();person1.sayName(); // Hanksvar person2 = new Person();person2.sayName(); //Hanksperson2.name = &quot;Gray&quot;; person2.sayName(); //Gray</code></pre><p>更简单的原型语法： 将原型对象中的所有属性和方法写在一个对象字面量中（相当于重写原型对象）。原型模式的主要问题是：所有实例都会取得相同的默认值，而且更致命的是一个实例修改原型对象的某个属性会在所有实例中体现出来。</p><h4 id="5-构造函数与原型的组合模式"><a href="#5-构造函数与原型的组合模式" class="headerlink" title="5. 构造函数与原型的组合模式"></a>5. 构造函数与原型的组合模式</h4><p>这种方式是创建自定义类型最常见的模式，用构造函数模式定义实例属性，而用原型模式定义共享的属性和方法。这种模式集两者之长，不仅支持传递参数，还最大限度的节省了内存。</p><pre><code class="javascript">function Person(name, age){    this.name = name;    this.age = age;};Person.prototype.sayName = function(){    return this.name;};</code></pre><h4 id="6-动态原型模式"><a href="#6-动态原型模式" class="headerlink" title="6. 动态原型模式"></a>6. 动态原型模式</h4><p>这种模式将原型的初始化放在构造函数中进行，通过判断某个方法是否已定义来决定是否需要初始化原型：</p><pre><code class="javascript">function Person(name, age){    this.name = name;    this.age = age;    //仅在sayName函数未定义的时候（初次调用）才初始化原型对象    if(typeof sayName != &quot;function&quot;){        Person.prototype.sayName = function(){            return this.name;        };    }};</code></pre><h4 id="7-寄生构造函数模式"><a href="#7-寄生构造函数模式" class="headerlink" title="7. 寄生构造函数模式"></a>7. 寄生构造函数模式</h4><p>基本思想是创建一个函数，用于封装创建对象的代码，然后再返回新创建的对象，注意与工厂模式的区别。</p><pre><code class="javascript">// 在函数内创建对象，给新创建的对象添加属性和方法，并显示的返回。function Person(name){    var obj = new Object();    obj.name = name;    obj.getName = function(){        return this.name;    };    return obj;}//与工厂模式的区别：这里用new操作符创建实例var person = new Person(&quot;Test&quot;);person.getName(); //Test</code></pre><p>该模式可用来为某些构造函数添加一些额外的方法，但是又不想直接修改原来的构造函数（如不想修改原生的Array构造函数）</p><h4 id="8-稳妥构造函数模式"><a href="#8-稳妥构造函数模式" class="headerlink" title="8. 稳妥构造函数模式"></a>8. 稳妥构造函数模式</h4><p>稳妥对象没有公共属性和方法，构造函数中红不使用this对象，注意与寄生构造函数模式的区别</p><pre><code class="javascript">// 在函数内创建对象，给新创建的对象添加属性和方法，并显示的返回。function Person(name){    var obj = new Object();    var name = name;    obj.getName = function(){        //不引用this        return name;    };    return obj;}//与工厂模式的区别：这里用new操作符创建实例var person = Person(&quot;Test&quot;);person.getName(); //Test</code></pre><p>除了使用sayName()方法外，没有其他方式可以访问其中的数据成员。</p><p>以上8种创建JS对象的方法中，原型与构造函数组合模式和动态原型模式是一定要掌握的，具体使用哪一种模式需要根据具体的项目及要求来选择。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简易Javascript 模板引擎</title>
      <link href="/2017/02/09/js-template-engine/"/>
      <url>/2017/02/09/js-template-engine/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在研究学习JavaScript的模板引擎的实现原理，读到<a href="https://github.com/krasimir">Krasimir Tsonev</a>的这篇介绍JS模板引擎实现原理的文章，对于新手很是受用，因此翻译过来。</p></blockquote><blockquote><p>原文链接：<a href="http://krasimirtsonev.com/blog/article/Javascript-template-engine-in-just-20-line" target="_blank" rel="noopener">JavaScript template engine in just 20 lines</a></p></blockquote><a id="more"></a><p>我还在忙于开发基于JavaScript的预处理器——<a href="http://krasimirtsonev.com/blog/article/AbsurdJS-fundamentals" target="_blank" rel="noopener"><strong>AbsurdJS</strong></a>, 它最开始仅作为CSS预处理器，后来扩展为CSS/HTML预处理器。简而言之，它可以将JavaScript转换为CSS/HTML。自然的，由于它可以生成HTML，因此可以作为模板引擎使用，即将数据填充到标签中。</p><p>因此，我想写一个简单的模板引擎逻辑，来完美兼容现在的项目。<a href="http://krasimirtsonev.com/blog/article/AbsurdJS-fundamentals" target="_blank" rel="noopener"><strong>AbsurdJS</strong></a>主要作为NodeJS模块来使用，不过有时候也需要在客户端使用。我发现目前还没有引擎能满足这一需求，因为大多数引擎都是基于NodeJS运行环境的，从而很难移植到浏览器运行。我需要一个小巧且用纯JavaScript写的引擎。恰好<a href="http://ejohn.org/" target="_blank" rel="noopener"><strong>John Resig</strong></a>的<a href="http://ejohn.org/blog/javascript-micro-templating/" target="_blank" rel="noopener"><strong>这篇文章</strong></a>中提出的引擎满足我的需求。我对它稍作修改，并减缩到20行代码。研究这段脚本的原理是很有意思的事情。本文中我会一步一步重构这个引擎，以便读者能够理解来自John的绝妙idea。</p><p>首先，我们的模板引擎应该长这样：</p><pre><code class="js">var TemplateEngine = function(tpl, data) {    // magic here ...}var template = &#39;&lt;p&gt;Hello, my name is &lt;%name%&gt;. I\&#39;m &lt;%age%&gt; years old.&lt;/p&gt;&#39;;console.log(TemplateEngine(template, {    name: &quot;Krasimir&quot;,    age: 29}));</code></pre><p>一个简单的函数，输入参数是<em>tpl</em>模板和<em>data</em>对象。可以猜到，最终我们期望得到的结果应该是：</p><pre><code class="json">&lt;p&gt;Hello, my name is Krasimir. I&#39;m 29 years old.&lt;/p&gt;</code></pre><p>首先我们需要获得模板中的动态片段，然后用传入引擎中的真实数据替换它们。我们可以用正则表达式来实现，这不是我的强项，所以欢迎指正并提出更好的正则表达式。</p><pre><code class="js">var re = /&lt;%([^%&gt;]+)?%&gt;/g;</code></pre><p>这样，我们会捕获所有以&lt;%开头，以%&gt;结尾的的片段。标志位<em>g</em>表示获取所有的匹配项。接受正则表达式的方法有很多，这里我们需要的是一个元素是字符串的数组，这正是<a href="http://www.w3schools.com/jsref/jsref_regexp_exec.asp" target="_blank" rel="noopener"><em>exec</em></a>能干的事情。</p><pre><code class="js">var re = /&lt;%([^%&gt;]+)?%&gt;/g;var match = re.exec(tpl);</code></pre><p>用<em>console.log</em>将<em>match</em>变量打印出来，我们会得到：</p><pre><code class="js">[    &quot;&lt;%name%&gt;&quot;,    &quot; name &quot;,     index: 21,    input: &quot;&lt;p&gt;Hello, my name is &lt;%name%&gt;. I\&#39;m &lt;%age%&gt; years old.&lt;/p&gt;&quot;]</code></pre><p>现在，我们拿到数据了，但是如上所示，返回的数组仅有一个元素，而我们需要处理所有的匹配项。因此，我们要在上述代码的外面加一个<em>while</em>循环。</p><pre><code class="js">var re = /&lt;%([^%&gt;]+)?%&gt;/g, match;while(match = re.exec(tpl)) {    console.log(match);}</code></pre><p>运行上面的代码，可以同时得到&lt;%name%&gt;和&lt;%age%&gt;。</p><p>现在事情开始变得有趣了。我们需要将传入函数的真实数据来替换模板中的占位符。最简单的方法是对模板应用<em>.replace</em>方法。可以这样写：</p><pre><code class="js">var TemplateEngine = function(tpl, data) {    var re = /&lt;%([^%&gt;]+)?%&gt;/g, match;    while(match = re.exec(tpl)) {        tpl = tpl.replace(match[0], data[match[1]])    }    return tpl;}</code></pre><p>OK, 这有用，但当然还不够好。我们现在传入的是最简单的对象，所以可以用data[“property”]的方式来取值。但是在实际应用中，我们可能会遇到复杂的嵌套对象。例如，将我们的数据改为：</p><pre><code class="js">{    name: &quot;Krasimir Tsonev&quot;,    profile: { age: 29 }}</code></pre><p>现在我们的引擎失效了，因为当输入&lt;%profile.age%&gt;时，我们会得到data[“profile.age”]，这个值实际上是<em>undefined</em>。因此，我们需要修改引擎的实现。在这种情况下<em>.replace</em>方法无法胜任。最好的方式是在&lt;%和%&gt;之间放置JavaScript代码，最好能够根据传入的数据来执行。例如：</p><pre><code class="js">var template = &#39;&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\&#39;m &lt;%this.profile.age%&gt; years old.&lt;/p&gt;&#39;;</code></pre><p>该怎么实现呢？John用了<em>new Function</em>语法，也即以字符串为参数来创建函数。我们先看一个简单的例子：</p><pre><code class="js">var fn = new Function(&quot;arg&quot;, &quot;console.log(arg + 1);&quot;);fn(2); // outputs 3</code></pre><p>fn实际上是一个接收一个参数的函数，它的函数体是console.log(arg+1)；换句话说，上述代码等同于：</p><pre><code class="js">var fn = function(arg) {    console.log(arg + 1);}fn(2); // outputs 3</code></pre><p>通过这种方式，我们可以通过简单字符串来定义一个函数的参数和函数体。这正好满足我们的需求。但是在定义这样一个函数之前，我们需要构建函数的函数体。函数最终应返回编译好的模板。用之前的例子的话，编译好的模板应该是这样的形式：</p><pre><code class="js">return &quot;&lt;p&gt;Hello, my name is &quot; + this.name + &quot;. I\&#39;m &quot; + this.profile.age + &quot; years old.&lt;/p&gt;&quot;;</code></pre><p>我们需要将模板分成普通文本和有意义的JavaScript代码。如上所示，我们可以通过简单的拼接来得到想要的结果。但是，这种方法不能100%满足要求。因为我们传入的可执行的JavaScript代码可能会做循环，例如：</p><pre><code class="js">var template = &#39;My skills:&#39; + &#39;&lt;%for(var index in this.skills) {%>' + '<a href><%this.skills[index]%></%this.skills[index]%></a>' +'<%}%&gt;&#39;; < code></%}%&gt;&#39;;></code></pre><p>如果用拼接，结果会是这样：</p><pre><code class="js">return&#39;My skills:&#39; + for(var index in this.skills) { +&#39;&lt;a href=&quot;&quot;&gt;&#39; + this.skills[index] +&#39;&lt;/a&gt;&#39; +}</code></pre><p>毫无疑问，这肯定会报错。因此我决定采用John的文章中所用的方法：将所有的字符串片段存入一个数组中，最后再将数组的元素用join方法拼接起来。</p><pre><code class="js">var r = [];r.push(&#39;My skills:&#39;); for(var index in this.skills) {r.push(&#39;&lt;a href=&quot;&quot;&gt;&#39;);r.push(this.skills[index]);r.push(&#39;&lt;/a&gt;&#39;);}return r.join(&#39;&#39;);</code></pre><p>下一步，我们需要收集自定义函数的不同行。我们已经从模板中获得了一些信息。我们知道占位符的内容及其位置。所以通过使用一个辅助变量（<em>cursor</em>）我们就能能够得到预期的结果。</p><pre><code class="js">var TemplateEngine = function(tpl, data) {    var re = /&lt;%([^%&gt;]+)?%&gt;/g,        code = &#39;var r=[];\n&#39;,        cursor = 0, match;    var add = function(line) {        code += &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39;;    }    while(match = re.exec(tpl)) {        add(tpl.slice(cursor, match.index));        add(match[1]);        cursor = match.index + match[0].length;    }    add(tpl.substr(cursor, tpl.length - cursor));    code += &#39;return r.join(&quot;&quot;);&#39;; // &lt;-- return the result    console.log(code);    return tpl;}var template = &#39;&lt;p&gt;Hello, my name is &lt;%this.name%&gt;. I\&#39;m &lt;%this.profile.age%&gt; years old.&lt;/p&gt;&#39;;console.log(TemplateEngine(template, {    name: &quot;Krasimir Tsonev&quot;,    profile: { age: 29 }}));</code></pre><p>变量<em>code</em>用于保存函数的函数体。它以数组的定义开始，而<em>cursor</em>表示现在在模板中所处的位置。我们需要这样一个变量来遍历整个字符串并跳过数据片段。这里使用了一个<em>add</em>函数，它的作用是将代码行添加到<em>code</em>变量的末尾。这里有一个坑要注意：我们需要对双引号转义，否则生成的脚本会是非法的。运行整个实例，我们可以在控制台看到：</p><pre><code class="js">var r=[];r.push(&quot;&lt;p&gt;Hello, my name is &quot;);r.push(&quot;this.name&quot;);r.push(&quot;. I&#39;m &quot;);r.push(&quot;this.profile.age&quot;);return r.join(&quot;&quot;);</code></pre><p>呃… 与我们预期的不一致。这里的<em>this.name</em>和<em>this.profile</em>不应该加引号。对<em>add</em>方法做一点修改可以解决这个bug：</p><pre><code class="js">var add = function(line, js) {    js? code += &#39;r.push(&#39; + line + &#39;);\n&#39; :        code += &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39;;}var match;while(match = re.exec(tpl)) {    add(tpl.slice(cursor, match.index));    add(match[1], true); // &lt;-- say that this is actually valid js    cursor = match.index + match[0].length;}</code></pre><p>传入占位符的内容的同时传入一个布尔变量（表示传入的字符串是否是合法的js代码）。现在可以生成正确的函数体了。</p><pre><code class="js">var r=[];r.push(&quot;&lt;p&gt;Hello, my name is &quot;);r.push(this.name);r.push(&quot;. I&#39;m &quot;);r.push(this.profile.age);return r.join(&quot;&quot;);</code></pre><p>现在我们要做的是创建这个函数并执行它，在模板引擎的末尾，我们不返回<em>tpl</em>，而是返回这个函数：</p><pre><code class="js">return new Function(code.replace(/[\r\t\n]/g, &#39;&#39;)).apply(data);</code></pre><p>我们甚至不需要给这个函数传任何参数，我们用<em>apply</em>方法来调用它。它会自动设置作用域，因此我们用的<em>this.name</em>可以生效，这里的<em>this</em>实际上指向传入的data。</p><p>我们马上就要完成了。还有最后一件事，我们需要支持更复杂的操作，如：if/else语句和循环。仍用上面都的例子并应用目前为止的代码。</p><pre><code class="js">var template = &#39;My skills:&#39; + &#39;&lt;%for(var index in this.skills) {%>' + '<a href="#"><%this.skills[index]%></%this.skills[index]%></a>' +'<%}%&gt;&#39;; console.log(templateengine(template, { skills: [&quot;js&quot;, &quot;html&quot;, &quot;css&quot;] })); < code></%}%&gt;&#39;;></code></pre><p>结果会报错<em>Uncaught SyntaxError: Unexpected token for</em>。通过调试并输出<em>code</em>变量，我们就能发现问题所在。</p><pre><code class="js">var r=[];r.push(&quot;My skills:&quot;);r.push(for(var index in this.skills) {);r.push(&quot;&lt;a href=\&quot;\&quot;&gt;&quot;);r.push(this.skills[index]);r.push(&quot;&lt;/a&gt;&quot;);r.push(});r.push(&quot;&quot;);return r.join(&quot;&quot;);</code></pre><p>包含<em>for</em>循环的代码行不应该push到数组中，而应该放在脚本内执行。因此我们需要在给<em>code</em>添加内容之前多做一步检查。</p><pre><code class="js">var re = /&lt;%([^%&gt;]+)?%&gt;/g,    reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g,    code = &#39;var r=[];\n&#39;,    cursor = 0;var add = function(line, js) {    js? code += line.match(reExp) ? line + &#39;\n&#39; : &#39;r.push(&#39; + line + &#39;);\n&#39; :        code += &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39;;}</code></pre><p>引入了一个新的正则表达式，它告诉我们如果js代码以<em>if</em>、<em>for</em>、<em>else</em>、<em>switch</em>、<em>case</em>、<em>break</em>、<em>{</em>或<em>}</em>开始的话，则单纯的将这一行加到<em>code</em>末尾，否则则在外面包一层push语句。结果如下：</p><pre><code class="js">var r=[];r.push(&quot;My skills:&quot;);for(var index in this.skills) {r.push(&quot;&lt;a href=\&quot;#\&quot;&gt;&quot;);r.push(this.skills[index]);r.push(&quot;&lt;/a&gt;&quot;);}r.push(&quot;&quot;);return r.join(&quot;&quot;);</code></pre><p>现在，所有模板都能正确编译了。</p><pre><code class="js">My skills:&lt;a href=&quot;#&quot;&gt;js&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;html&lt;/a&gt;&lt;a href=&quot;#&quot;&gt;css&lt;/a&gt;</code></pre><p>实际上最后一步的修正使我们的引擎变得更加强大。我们可以直接在模板中使用复杂的逻辑。例如：</p><pre><code class="js">var template = &#39;My skills:&#39; + &#39;&lt;%if(this.showSkills) {%>' +    '<%for(var index in this.skills) {%>' +     '<a href="#"><%this.skills[index]%></%this.skills[index]%></a>' +    '<%}%&gt;&#39; + &#39;&lt;%} else {%>' +    '<p>none</p>' +'<%}%&gt;&#39;; console.log(templateengine(template, { skills: [&quot;js&quot;, &quot;html&quot;, &quot;css&quot;], showskills: true })); < code></%}%&gt;&#39;;></%}%&gt;&#39;></%for(var></code></pre><p>我对代码做了一些细小的优化，<a href="/assets/demo/TemplateEngine.js">最终版</a>如下所示：</p><pre><code class="js">var TemplateEngine = function(html, options) {    var re = /&lt;%([^%&gt;]+)?%&gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = &#39;var r=[];\n&#39;, cursor = 0, match;    var add = function(line, js) {        js? (code += line.match(reExp) ? line + &#39;\n&#39; : &#39;r.push(&#39; + line + &#39;);\n&#39;) :            (code += line != &#39;&#39; ? &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39; : &#39;&#39;);        return add;    }    while(match = re.exec(html)) {        add(html.slice(cursor, match.index))(match[1], true);        cursor = match.index + match[0].length;    }    add(html.substr(cursor, html.length - cursor));    code += &#39;return r.join(&quot;&quot;);&#39;;    return new Function(code.replace(/[\r\t\n]/g, &#39;&#39;)).apply(options);}</code></pre><p>它仅有15行！！！</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>My Blog</title>
      <link href="/2017/02/09/preface/"/>
      <url>/2017/02/09/preface/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="我的博客之旅"><a href="#我的博客之旅" class="headerlink" title="我的博客之旅"></a>我的博客之旅</h1><p>作为一个前端“老菜鸟”，我在研究生行将毕业之际才开始博客之旅，better late than never。一直以来，由于对自己的文笔不够自信，因此迟迟没有勇气开始写博客。在鹅厂实习半年以来，在老司机们的谆谆教诲和环境刺激之下，深刻了解到通过博客来总结和记录自己的知识栈是一种非常高效的方式。</p><a id="more"></a><p>最开始的时候图方便，就在CSDN和博客园上写博客，发现写起来不是很友好，也不喜欢它们的样式主题，再加上我自己是一个爱折腾的人，因此开始尝试搭建独立博客。阮一峰曾经说过，喜欢写博客的人会经历三个阶段：</p><ul><li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写</li><li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li><li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li></ul><p>而我正处于第一、第二阶段的过渡阶段，在众多选择之中，最终选择了Github Pages + Hexo来搭建我的独立博客。原因很简单，一是Github与git搭配的天然优势，二是Hexo简洁的风格和丰富的插件正合我意。本人是一个Google粉，自然而然大爱Material Design，因此整个博客选取的主题也是<a href="https://github.com/viosey/hexo-theme-material">Material风格</a>。</p><p>有了自己的独立博客就等于有了自己的一片田地，好好耕耘，终会收获丰硕的果实。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://litten.github.io/" target="_blank" rel="noopener">Litten的博客</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">阮一峰-搭建一个免费的，无限流量的Blog——github Pages</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Experience </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/assets/demo/TemplateEngine.js"/>
      <url>/assets/demo/TemplateEngine.js</url>
      
        <content type="html"><![CDATA[/*** @Author: Hankszhang* @Date:   2016-09-11* @Last modified by:   Hankszhang* @Last modified time: 2016-09-11* Cite from https://github.com/krasimir/absurd/blob/master/lib/processors/html/helpers/TemplateEngine.js*/module.exports = function(html, options) {    var re = /<%(.+?)%>/g,        reExp = /(^( )?(var|if|for|else|switch|case|break|{|}|;))(.*)?/g,        code = 'var r=[];\n',        cursor = 0,        result;    var add = function(line, js) {        js ? (code += line.match(reExp) ? line + '\n' : 'r.push(' + line + ');\n') :            (code += line != '' ? 'r.push("' + line.replace(/"/g, '\\"') + '");\n' : '');        // 返回函数本身，使得可以连续调用        return add;    }    while (match = re.exec(html)) {        add(html.slice(cursor, match.index))(match[1], true);        cursor = match.index + match[0].length;    }    add(html.substr(cursor, html.length - cursor));    code += 'return r.join("");';    try {        result = new Function(code.replace(/[\r\t\n]/g, ' ')).apply(options);    }    catch (err) {        console.error("'" + err.message + "'", " in \n\nCode:\n", code, "\n");    }    return result;}</%(.+?)%>]]></content>
      
    </entry>
    
    
  
</search>
